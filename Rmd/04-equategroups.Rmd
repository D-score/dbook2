# Equate groups {#ch:equategroups}

This chapter introduces the concepts and tools needed to link assessments made by different instruments administered across multiple cohorts. Our methodology introduces the idea of an equate group. Systematic application of equate groups provides a robust yet flexible methodology to link different instruments. Once the links are in place, we may combine the data to enable meta-analyses and related methods.

* What is an equate groups (\@ref(sec:eqdef))
* Concurrent calibration (\@ref(sec:concurrent))
* Requirements of equate groups (\@ref(sec:equaterules))
* Statistical framework (\@ref(sec:statisticalframe))
* Common latent scale (\@ref(sec:commonscale))
* Quantifying equate fit (\@ref(sec:equatefit))
* Differential Item Functioning (\@ref(sec:equatedif))

## What is an equate group? {#sec:eqdef}

An *equate group* is a set of two or more milestones that measure the same thing in (perhaps slightly) different ways. Table \@ref(tab:example2words) contains an example of an equate group, containing items that measure the ability to form two-word sentences. Also, Figures \@ref(fig:poteq) and \@ref(fig:badeq) show examples of equate groups. 

Equate groups can be of different quality. We can use high-quality equate groups to link instruments by restricting the difficulty of all equate group members to be identical. Equate groups thus provide a method for bridging different tools.

```{r equateex, fig.cap = '(ref:equateex)'}
knitr::include_graphics("fig/equate_ex.png")
```
(ref:equateex) Example of three instruments that are bridged by common items in equate groups.

Figure \@ref(fig:equateex) displays items from three different instruments that measure child development. The instruments contain a few milestones shared by all tools. 

The shared items make up equate groups, as displayed by the arrows between them. In the example, all three instruments share one milestone ("walk alone"). The "sitting" and "clap hand" items appear in two tools. There are three equate groups.

## Concurrent calibration {#sec:concurrent}

Patterns as in Figure \@ref(fig:equateex) occur if we have multiple forms of the same instrument. Although in theory, there might be sequence effects, the consensus is that we may ignore form-effects. Equate groups with truly shared items are of high-quality. We may collect the responses on all items from a high-quality equate group into the same column of the data matrix. As a consequence, the shared item from different forms will automatically have one difficulty estimate.

The procedure described above is known as *concurrent calibration*. See @kim1998 for background. The method simultaneously estimates the item parameters for all instruments. Concurrent calibration is an attractive option for various reasons:

* It yields a common latent scale across all instruments;
* It is efficient because it calibrate all items in a single run;
* It produces more stable estimates for shared items for small samples.

However, concurrent calibration depends on a strict distinction between items that are indeed the same in different instruments and items that differ. 

In practice, strict black-white distinctions may not be possible. Items that measure the same skill may have been adapted to suit the format of the instrument (e.g. number of response options, question formulation, and so on). Also, investigators may have altered the item to suit the local language and cultural context. Such changes may or may not affect the measurement properties. 

In practice, we need to perform concurrent calibration to multiple - perhaps slightly dissimilar - milestones. When confronted with similar - but not identical - items, our strategy is first to form equate groups. We then explore and test the quality of each equate group, in the hope that we will find enough high-quality equate groups to bridge instruments.

<!-- I have outcommented this because it seems to go in a different direction, and not really needed for the main story line
Also, when in example Figure \@ref(fig:equateex) the first and second instruments are both administered in the same cohort and the third in a second, concurrent calibration is not possible for common items in the first two instruments. In these situations, the equate group method is a more flexible way to link items. The equate groups methods works with similar assumptions as the concurrent calibration method, but with the flexibility to explore, test and modify the sets of equate items (i.e. equate groups) used in the model. -->

## Requirements of equate groups {#sec:equaterules}

Statistical information and subject matter experts form the basis for the assignment of items to eligible equate groups. In actual modeling, there are “active” equate groups (i.e. equate groups for which the restriction is actually applied) and “passive” equate groups (i.e. similar items for which the restriction is not applied). Only active groups bridge the different instruments in the final model.

The following strategies are recommended to select equate groups:

* As a first step, content experts can start by mapping similar items. For example use one instrument as a reference and map the items of other instruments to those items (see section \@ref(sec:mapping)).
* In a second step, the mapping can be visualized by plotting the mapped items in one figure (see section \@ref(sec:viewmapping)). That way, potential matches can be verified and confirmed if they show similar patterns or broken up if they seem poor mappings. In this step, both statistical and content expertise can be utilized.
* Next, the model can be fitted using a selection of potential matches as active equate groups. The technical details of this model are explained in section \@ref(sec:statisticalframe). The selection of the final active equate groups for the model is an iterative process where two important qualifications should be considered: (1) the active equate groups should link all cohorts and instruments. (2) To enhance the functioning of equate groups, the active equate groups are preferably distributed over the scale, rather than centered at one point.
* The infit and outfit can be calculated for equate groups, which provides a natural measure of equate group quality (see section \@ref(sec:equatefit)).
* The performance of the equategroups across subgroups or cohorts can be tested with methods designed to detect differential item functioning (see section \@ref(sec:equatedif)).

In general, the use of equate groups is very relevant when the abilities differ across cohorts. In that case, equate groups are very helpful to place the abilities across the different cohorts on the same scale. However, when cohort abilities are relatively uniform and the risk of mis-specification of the equate groups is high, a model without equate groups is preferred.


## Statistical framework {#sec:statisticalframe}

The preferred measurement model for development data is the Rasch model. An introduction of the Rasch model geared towards the $D$-score is described in https://stefvanbuuren.name/dbook1/. The Rasch model, models the probability of passing an item as a logistic function of the difference between each person’s ability and the difficulty of the item, see equation \@ref(eq:rasch).

\begin{equation}
\pi_{ni} = \frac{exp(\beta_n - \delta_i)}{1+exp(\beta_n -\delta_i)} (\#eq:rasch)
\end{equation}

The symbols used in equation \@ref(eq:rasch) are explained in Table \@ref(tab:symbols). The log odds that a person with ability $\beta_n$ answers an item with difficulty $\delta_i$ correctly is the difference between the person’s ability and the item’s difficulty $(\beta_n-\delta_i)$ [@wright1982].

In order to facilitate the use of equate groups to link similar items used in different instruments and cohorts, the Rasch model can be extended. This extension holds the restriction that item difficulties of similar items are constrained as equal. Wright and Masters [@wright1982] present a simple method to equate the difficulty between two test forms that have common item links. This is done by estimating the shift in difficulty as the weighted average of difficulty differences of the linked items, and using this weighted average to align the difficulties of the test forms. We can use this way of aligning forms, to align item difficulties of items in an equate group, see equation \@ref(eq:raschequate).

\begin{equation}
\delta_q = \frac{\sum_{l}^{i} \delta_iw_i}{\sum_{l}^{l} w_i} (\#eq:raschequate)
\end{equation}
 

Symbol | Term  | Description
------------- | ------------- | -----------
$\beta_n$     | Ability       | True (but unknown) developmental score of child $n$
$\delta_i$    | Difficulty    | True (but unknown) difficulty of item $i$
$\delta_q$    | Difficulty    | The combined difficulty of the items in equate group $q$
$\pi_{ni}$    | Probability   | Probability that child $n$ passes item $i$
$l$           |               | The number of items in the equate group
$w_i$         |               | The number of respondends with an observed score on item $i$

: (\#tab:symbols) Overview the symbols used in equations \@ref(eq:rasch) and \@ref(eq:raschequate).

## Common latent scale {#sec:commonscale}

The end goal for using the equate group method to model development items is to measure development on one common latent scale, the $D$-score. That way, the measure (i.e. $D$-score) can be obtained, irrespective of which instrument is used in which population.

In Figure \@ref(fig:commonscale) the $D$-scores are displayed for three cohorts from the GCDG study: Netherlands 1 (GCDG-NLS-SMOCC), Ethiopia (GCDG-ETH) and Colombia 2 (GCDG-COL-LT42M). As decribed in section \@ref(sec:cohorts), the Netherlands 1 study contains the ddi; Ethiopia the by3; and Colombia the by3, den, asq and bdi. Accordingly there is some natural ovelap in items between Ethiopia and Colombia via the by3 items. However, the Netherlands 1 cohorts is not linked via the items. In the upper plot, no equate groups were used in the model and in the lower plot, equate groups linked the cohorts.

```{r commonscale, echo=FALSE, fig.cap='(ref:commonscale)', message=FALSE, warning=FALSE, cache = TRUE}
library(ggplot2)
library(dmetric)
library(gseddata)
library(gridExtra)
library(dplyr)

## model without equate groups
varlist_o <- dmetric::prepare_items(study = c("Netherlands 1", "Ethiopia", "Columbia 2"))
sub_items <- dscore::rename_gcdg_gsed(varlist_o$items)
varlist <- list(adm = c("subjid", "agedays", "cohort", "cohortn", "subjido"),
                items = sub_items)
sub_lean <- gseddata::get_data(cohorts = c(43,50,53), items = varlist$items, adm = varlist$adm)
model2 <-  fit_dmodel(varlist, data = sub_lean, equate = NULL,
                      name = "no_equates", age_unit = "years")

df1 <- model2$dscore %>% mutate(agemos = a*12)

p1 <- ggplot(data = df1) +  
  geom_point(aes(agemos, d, group=cohort, color=cohort)) +
  scale_colour_manual(values = gseddata::get_palette("study"), na.value = "grey")+
  xlab("Age (months)")+
  ylab("D-score") +  
  theme(legend.position =  c(0.8,0.2), legend.title = element_blank())

#model with equate groups
model <- dmetric::model_lean
studies <- c("GCDG-ETH", "GCDG-NLD-SMOCC", "GCDG-COL-LT42M")
df2 <- model$dscore[which(model$dscore$cohort %in% studies),] %>% mutate(agemos = a *12)

p2 <- ggplot(data = df2)+
  geom_point( aes(agemos, d, group=cohort, color=cohort))+
  scale_colour_manual(values = get_palette("study"), na.value = "grey")+ 
  xlab("Age(months)")+
  ylab("D-score") +  
  theme(legend.position =  c(0.8,0.2), legend.title = element_blank())

grid.arrange(p1, p2)


```
(ref:commonscale) Example of three cohorts with and without equage group linking.

In the plot for the model without equate groups it can be observed that the scales for the Ethiopia and Colombia 2 studies are linked naturally via the shared items from by3. The Netherlands 1 cohort is not connected and follows a different track. In the plot for the model with equate groups, the scales for all three cohorts are connected. This example shows that the use of equate groups brings the abilities for children in different cohorts measured with different instrument on one scale.


## Quantifying equate fit {#sec:equatefit}

In the Rasch philosophy it is the task of the data to fit the Rasch model. In order to verify the fit of the data to the model, we can assess the item fit and the person fit. Both fit measures are explained thorougly in https://stefvanbuuren.name/dbook1/ch-evaluation.html. When we use equate groups in the Rasch model, we can also use these fit indices to determine the fit of the items in the equate groups.


### Well fitting equate groups

```{r plot_p_d_equate, message=FALSE, warning=FALSE, include=FALSE}
library(gridExtra)
library(dmetric)
library(dscore)
library(ddata)
library(dplyr)
library(tidyr)
##plot p d equate but group for item instead of study.

plot_p_d_equate_i <- function(data,
                            model,
                            equates = NULL,
                            passive = FALSE,
                            metric = "dscore",
                            show_rug = TRUE,
                            show_curve = TRUE,
                            show_fit = TRUE,
                            file = NULL,
                            device = "pdf",
                            ...) {
  lean <- gseddata::is.lean(data)
  model_name <- model$name
  names(model$itembank)[names(model$itembank) == "lex_gsed"] <- "item"

  if (!"agedays" %in% names(data)) {
    data$agedays <- as.integer(data$age / 12 * 365.25)
  }

  # if no equates argument is specified, get equates from the
  # model, find equate groups with at least 2 items in the model
  if (is.null(equates))
    equatelist <- dmetric::get_equates(model)

  # if list of equate groups (name with item)
  if (is.list(equates) & length(equates) > 0) equatelist <- equates

  # if names in character vector, get equates subset from model
  if (!is.list(equates) & !is.null(equates))
    equatelist <- model$fit$equate[equates]

  items_eq <- unique(unlist(equatelist))
  items <- intersect(model$items, items_eq)

  # no items left, return
  if (is.null(items)) return()

  # merge data to obtain d
  if (metric == "dscore") {
    modelb <- model$dscore
    colnames(modelb)[colnames(modelb) == "d"] <- "b"
    delta <- dscore::get_tau(model$items, "", model$itembank)
    beta_breaks <- seq(0, 80, 2)
    xlim <- c(0, 80)
    scale <- model$transform[2]
  }

  if (metric == "logit") {
    modelb <- model$beta_l
    delta <- model$fit$item[, "b"]
    names(delta) <- rownames(model$fit$item)
    delta <- delta[items]
    beta_breaks <-
      calculate_logit(seq(0, 80, 2), transform = model$transform)
    xlim <- c(-15, 25)
    scale <- 1
  }

  # merge data to obtain b
  if (!"agedays" %in% names(modelb))
    modelb$agedays <- as.integer(modelb$age * 365.25)
  if (!"study" %in% names(modelb))
    modelb$study <- modelb$cohort
  if (!"id" %in% names(modelb))
    modelb$id <- as.numeric(modelb$subjido)
  modelb <- modelb %>%
    select("study", "id", "agedays", "b")

  if (!lean) {
    if (!"study" %in% names(data))
      data$study <- data$cohort
    if (!"id" %in% names(data))
      data$id <- as.numeric(data$subjido)
    data <- data %>%
      select(one_of(c("study", "id", "agedays", items))) %>%
      pivot_longer(names_to = "item", values_to = "value", cols = -one_of(c("study", "id", "agedays"))) %>%
      drop_na("value", "study", "id", "agedays") %>%
      left_join(modelb, by = c("study", "id", "agedays"))
  }
  if (lean) {
    data <- data$itm %>%
      filter(item %in% items) %>%
      left_join(data$visit, by = c("subjid", "agedays"))%>%
      mutate(id = as.numeric(.data$subjido)) %>%
      left_join(modelb, by = c("id", "agedays"))
  }

  if (!"study" %in% names(data) & !"cohort" %in% names(data))
    data$study <- NA
  if (!"study" %in% names(data) & "cohort" %in% names(data))
    data$study <- data$cohort

  # proportion pass per dscore group
  # observations per months (n) by study and item
  pass <- data %>% filter(item %in% items) %>%
    drop_na("value", "b") %>%
    mutate(dgp = cut(.data$b, breaks = beta_breaks),
           age = .data$agedays / 365.25) %>%
    group_by(study, item, dgp) %>%
    summarise(
      p = round(100 * mean(.data$value, na.rm = TRUE)),
      a = mean(.data$age, na.rm = TRUE),
      b = mean(.data$b, na.rm = TRUE),
      n = n()) %>%
    ungroup() %>%
    left_join(model$itemtable, by = "item") %>%
    arrange(.data$equate, desc(.data$item))

  # define data for rug plot
  data_rug <- NULL
  if (show_rug)
    data_rug <- data %>%
    mutate(age = .data$agedays / 365.25) %>%
    select(one_of(c("study", "item", "age", "value", "b"))) %>%
    group_by(.data$study, .data$item, .data$age, .data$value) %>%
    summarise(b = mean(.data$b, na.rm = TRUE)) %>%
    ungroup() %>%
    left_join(model$itemtable, by = "item")%>% ##added to have instrument variable in rug data
    drop_na("b")

  plots <-
    plot_by_grp_i(
      pass,
      data_rug = data_rug,
      model_name = model_name,
      type = "d",
      metric = metric,
      xlim = xlim,
      package = model$data_package, ...)

  # add logistic curves
  if (show_curve) {
    idx <- match(names(plots), model$itembank$equate)
    location <- model$itembank$tau[idx]
    plots <- dmetric::show_logistic_curve(plots,
                                 location = location,
                                 scale = scale)
  }
  # add equate fit
  if (show_fit)
    plots <- show_equate_fit(plots, model$equate_fit, xlim = xlim)

  # add label signalling ACTIVE equate
  #plots <- show_active_equate(plots, active = model$active_equates)

  # save
  if (!is.null(file) & device == "pdf") {
    pdf(file,
        onefile = TRUE,
        width = 10,
        height = 5)
    lapply(plots, print)
    message("Saved to: ", file)
    dev.off()
  }

  if (!is.null(file) & device == "png") {
    paths <- paste0(file, names(plots), ".png")
    purrr::pwalk(list(filename = paths, plot = plots), ggsave)
  }

  invisible(plots)
}

plot_by_grp_i <- function(pass,
                        by_name = "equate",
                        model_name = "unspecified",
                        quiet = FALSE,
                        type = "d",
                        metric = "dscore", ...) {
  # sort equate groups
  by_grp <- unique(pass$equate)

  # remove missing groups
  if (any(is.na(by_grp))) by_grp <- by_grp[-which(is.na(by_grp))]

  # pre-allocate list of ggplots
  plot_list <- vector("list", length(by_grp))
  names(plot_list) <- by_grp

  # loop over plots
  for (i in seq_along(plot_list)) {
    if (!quiet) cat("Group: ", as.character(i), by_grp[i], "\n")
    if (type == "d") plot_list[[i]] <-
        plot_d_one_grp_i(pass,
                       by_name = by_name, by_value = by_grp[i],
                       i = i, model_name = model_name,
                       metric = metric, ...)
    else plot_list[[i]] <-
        plot_a_one_grp(pass,
                       by_name = by_name, by_value = by_grp[i],
                       i = i, model_name = model_name,
                       metric = metric, ...)
  }

  return(plot_list)
}

plot_d_one_grp_i <- function(pass,
                           data_rug = NULL,
                           by_name,
                           by_value,
                           i = 0,
                           min_n = 10,
                           model_name = "unspecified",
                           metric = "dscore",
                           xlim = c(0,80),
                           package = "gseddata",
                           ...) {
  if (by_name == "item")
    data_plot <- pass %>%
      filter(.data$item == by_value & .data$n >= min_n)

  if (by_name == "equate")
    data_plot <- pass %>%
      filter(.data$equate == by_value & .data$n >= min_n)

  items <- unique(data_plot$item)

  if (!is.null(data_rug) ){
  data_rug <- data_rug %>%
    filter(.data$item %in% items)
  }

  labels <- data_plot$label[match(items, data_plot$item)]
  labels <- substr(labels, 1L, 60L)

  # add study
  if (!"study" %in% names(data_plot))
    data_plot$study <- data_plot$cohort
  if (!"study" %in% names(data_rug))
    data_rug$study <- data_rug$cohort


  if (model_name != "") model_name<- paste("-", model_name)

  plot <- ggplot(data_plot, aes(b, p, group = interaction(study, item),
                                colour = instrument)) + ##_i instrument instead of study
    scale_x_continuous(paste0("Ability (", metric,") ", model_name,""),
                       limits = xlim,
                       breaks = seq(xlim[1], xlim[2], diff(xlim) / 8)) +
    scale_y_continuous("% pass", breaks = seq(0, 100, 10),
                       limits = c(0, 100)) +
    scale_colour_manual(values = dmetric::get_palette("instrument", package = package),
                        na.value = "grey")

  # add rugs
  if (!is.null(data_rug)) {
    if (nrow(data_rug) >= 1)
      plot <- plot +
        geom_rug(aes_string(x = "b", y = "value",
                            group = "instrument", colour = "instrument"),##_i instrument instead of study
                 data = filter(data_rug, .data$value == 0),
                 position = "jitter", sides = "b", size = 0.2) +
        geom_rug(aes_string(x = "b", y = "value",
                            group = "instrument", colour = "instrument"),##_i instrument instead of study
                 data = filter(data_rug, .data$value == 1),
                 position = "jitter", sides = "t", size = 0.2)
  }

  # add proportions
  if (nrow(data_plot) >= 1)
    plot <- plot +
    geom_line() + geom_point()

  # annotations
  plot <- plot +
    theme(legend.position = c(0.99, 0.05), legend.justification = c(1, 0),
          legend.key.size = unit(3.0, "mm"),
          legend.spacing.y = unit(0.5, "mm"),
          legend.background = element_rect(fill = "transparent", colour = "transparent")) +
    guides(fill = guide_legend(title = NULL)) +
    guides(col = guide_legend(ncol = 1)) +
    annotate("text", x = (xlim[1] + 1), y = 2, hjust = 0,
             label = as.character(i)) +
    annotate("text", x = (xlim[1] + 7), y = 2, hjust = 0,
             label = by_value)

  # item nams
  if (length(labels) > 0) {
    for (l in length(labels):1) {
      plot <- plot + annotate("text", x = (xlim[1] + 1), y = 7 + (l - 1) * 5, hjust = 0,
                              label = items[l], family = "Courier", fontface = "bold")
      if (!is.na(labels[l]))
        xfac <- 14
      if (metric == "logit") xfac <- 8
      plot <- plot + annotate("text", x = (xlim[1] + xfac), y = 7 + (l - 1) * 5, hjust = 0,
                              label = labels[l])
    }
  }
  return(plot)
}

show_equate_fit <- function(plot, equate_fit, xlim = c(0, 80)) {
  if (is.null(equate_fit))
    return(plot)
  if (is.ggplot(plot))
    return(annotate_item_fit(plot, itemfit = equate_fit))
  if (is.list(plot)) {
    for (i in seq_along(plot)) {
      the_name <- names(plot)[i]
      itemfit <- filter(equate_fit, equate == the_name)
      if (nrow(itemfit) == 1) plot[[i]] <-
        annotate_item_fit(plot[[i]], itemfit = itemfit, xlim = xlim)
    }
  }
  return(plot)
}

show_active_equate <- function(plot, active) {
  # active: vector of names of active equate groups
  # if (is.ggplot(plot)) return(annotate_active_equate(plot))
  #if (is.list(plot)) {
    for (i in seq_along(plot)) {
      the_name <- names(plot)[i]
      if (the_name %in% active)
        plot[[i]] <- annotate_active_equate(plot[[i]])
    }
  #}
  return(plot)
}

annotate_item_fit <- function(plot, itemfit, pole = TRUE, xlim=c(0,80)) {
  # function assumes that location is scalar and plot is ggplot
  if (!is.ggplot(plot)) stop("Argument plot not a ggplot.")
  if (is.na(itemfit[1])) return(plot)
  if (pole) {
    plot <- plot +
      annotate("text", x = (xlim[1]+1), y = 97, hjust = 0,
               label = paste0("Outfit ",
                              round(itemfit$outfit, 2),
                              "(",
                              round(itemfit$outfit_z, 2),
                              ")"))
    plot <- plot +
      annotate("text", x = (xlim[1]+1), y = 92, hjust = 0,
               label = paste0("Infit  ",
                              round(itemfit$infit, 2),
                              "(",
                              round(itemfit$infit_z, 2),
                              ")"))
  }
  else {
    plot <- plot +
      annotate("text", x = (xlim[1]+1), y = 82, hjust = 0,
               label = paste0("Outfit ",
                              round(itemfit$outfit, 2),
                              "(",
                              round(itemfit$outfit_z, 2),
                              ")"))
    plot <- plot +
      annotate("text", x = (xlim[1]+1), y = 77, hjust = 0,
               label = paste0("Infit  ",
                              round(itemfit$infit, 2),
                              "(",
                              round(itemfit$infit_z, 2),
                              ")"))
  }
  plot
}

```

The evaluation of *equate fit* involves comparing the observed probabilities of endorsing the items in the equate group to the estimated probability of endorsing the items in the equate group. In an equate group there is an empirical curve for each item in the equate group and one shared estimated curve. The empirical curves should all be close to the estimiated curve for a good equate fit, as presented in the two examples in Figure \@ref(fig:ploteqfit).

```{r ploteqfit, results = 'hide', fig.keep = 'all', fig.height = 11, warning = FALSE, fig.cap = '(ref:ploteqfit)', message = FALSE}
ps <- plot_p_d_equate_i(data = dmetric::gcdg_lean , model = dmetric::model_lean)
grid.arrange(ps[["REC6"]], ps[["GM42"]])
```
(ref:ploteqfit) Two equate groups that present a good equate fit.

The equate *Turns head to sound of bell* is asked in slightly different formats in the Bayley I (by1), Dutch Development Instrument (ddi) and the Denver (den). The three items are combined in an equate group and the empirical data are clored differently for each instrument in Figure \@ref(fig:ploteqfit). Equate *Walks alone* is administered in six different instruments (bar, by1, by2, by3, ddi and gri). For both equate groups, the empirical data for each instrument is close to the fitted dashed line, which indicates a good equate fit. The infit and outfit indices, shown in Figure\@ref(fig:ploteqfit), confirm the good fit (fit < 1).

### Equate groups with poor equate fit

In modeling with equate groups, selecting the perfect combination of equate groups is a crucial step. Poor fitting equate groups need to be set as passive equate groups, such that the items in the group are not restricted to the same difficulty anymore. In a poor fitting equate group the empirical curve for each item in the equate group are not close to the shared estimated curve. Additionally, the fit indices show poor fit as well (fit > 1). Two examples of poor equate fit are shown in Figure \@ref(fig:ploteqpoor).

```{r ploteqpoor, results = 'hide', fig.keep = 'all', fig.height = 11, warning = FALSE, fig.cap = '(ref:ploteqpoor)', message = FALSE, cache = TRUE}

varlist <- list(adm = c("subjid", "agedays", "cohort", "subjido"),
                items = gseddata::gcdg_items)
equatelist_poor <- gseddata::gcdg_equatelist
equatelist_poor$COG24 <- c("by1mdd066", "denfmd013")
#equatelist_poor$GM45 <- c("ddigmd070", "grigmd208")
#equatelist_poor$EXP23 <- c("barxxx014", "denlgd017", "grihsd213")
equatelist_poor$EXP12 <- c("by1mdd101", "ddicmm034", "grihsd011")
model_poor <- fit_dmodel(varlist, data = dmetric::gcdg_lean, equate = equatelist_poor,
                    name = "", age_unit = "years")

psp <- plot_p_d_equate_i(data = dmetric::gcdg_lean, model = model_poor)

grid.arrange(psp[["COG24"]], psp[["EXP12"]])
```
(ref:ploteqpoor) Two equate groups that present a poor equate fit.

The equate *Bangs in play / Bangs 2 blocks* is asked in two different instruments, the Bayley I (by1) and the Denver (den). The empricial curve for the Bayley I item is not close to the fitted curve. The fitted curve is closer to the Denver item, which suggests that the equate difficulty is mostly based on the Denver item data. The fit indices are both larger than 1 also indicating the poor fit. The equate *Jabbers expressively* is asked in different forms in three instruments (i.e. by1, ddi, and gri). The empirical curves, with different colors for ech instrument, are not close to each other, nor close to the fitted curve. Also for this equate the fit indices confirm the poor fit (fit > 1). Both equates should be deactivated in an updated model.

## Differential item functioning {#sec:equatedif}

An important assumption for equate groups is that the items in the group work in the same way across the different cohorts, i.e., there is no differential item functioning. This means that the items in the equate group are equally difficult for children in different cohorts. This assumption is critical for active equate groups. If it is not met, restricting the difficulty parameters as equal across cohorts may introduce unwanted bias in comparisons between cohorts.

### Good equate group without DIF

In Figure \@ref(fig:plotnoeqdif), two active equate groups are displayed with empirical curves in different colors for each cohort. In both equate groups the curves are close to each other and to the fitted dashed curve. The lack of difference between the curves for the differnt cohorts, shows that there is no different equate functioning (i.e. different item functioning, DIF) between the cohorts.

```{r plotnoeqdif, results = 'hide', fig.keep = 'all', fig.height = 11, warning = FALSE, fig.cap = '(ref:plotnoeqdif)', message = FALSE}

pdif <- dmetric::plot_p_d_equate(data = dmetric::gcdg_lean , model =dmetric::model_lean, passive = TRUE, show_fit = FALSE)
grid.arrange(pdif[["FM31"]], pdif[["EXP26"]])

```
(ref:plotnoeqdif) Two equate groups that present no differential item functioning between cohorts.


### Poor equate groups with DIF for study

In Figure \@ref(fig:ploteqdif), two passive equate groups are displayed, that show differential item functioning between cohorts. The empirical curves are displayed for each cohort separately in different colors. The difference between these curves shows the differential item functioning. For example, the item *Throws ball*, is easier for children in the South-Africa cohort (purple curve; GCDG-ZAF), and more difficult for children in Colombia (blue curve; GCDG-COL-LT42M). In other words, the probability to pass the item given the D-score (i.e. item difficulty) differs between the cohorts. The same goes for the item *Says more than 5 words*, which is easier for childen in Jamaica (yellow and pink curves; GCDG-JAM-LBW and GCDG-JAM-SUNTED) and more difficult for children in Ecuador (green; GCDG-ECU).

```{r ploteqdif, results = 'hide', fig.keep = 'all', fig.height = 11, warning = FALSE, fig.cap = '(ref:ploteqdif)', message = FALSE}

grid.arrange(pdif[["GM44"]], pdif[["EXP23"]])

```
(ref:ploteqdif) Two equate groups that present differential item functioning between cohorts.

