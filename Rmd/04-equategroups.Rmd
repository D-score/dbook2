# Equate groups {#ch:equategroups}

## Definition of equate groups

A group of items that measure the same thing in (perhaps slightly) different
ways is called an “equate group”. An equate group can link items across
instruments by restricting their difficulty estimates to be identical. Equate
groups provide an extra option for bridging different instruments to the same
scale. Figure \@ref(fig:equateex) displays items from three different
instruments that measure child development. The instruments contain some common
items that are measured in multiple instruments, but also unique items. The
common items can be linked in an equate group as displayed by the arrows between
them. In the example there is one (common) item that is equivalent in all three
instruments (i.e. walk alone). The item "sitting" occurs in both the first (i.e.
blue) and the second (i.e. green) instrument and the item "clabs hand together"
occurs in the second (i.e. green) and third (i.e. orange instrument).

```{r equateex, fig.cap = '(ref:equateex)'}
knitr::include_graphics("fig/equate_ex.png")
```
(ref:equateex) Example of three instruments that are bridged by common items in equate groups.

## Concurrent calibration

When each instrument is administered in a different cohort, the cohorts can be
linked by placing the common items in the same column. The common items will
have the same difficulty estimates due to linking with "concurrent calibration".
In concurrent calibration the item parameters for all instruments are estimated
simulateously. Concurrent calibration is an attractive option, thought this
method warrants a strict distinction between items that are truly the same in
different instruments and items that differ. In practice during instrument
development, items measuring the same skill but from different instruments may
have been adapted to suit the format of the instrument (e.g. number of response
options, question formulation, and so on) or the local language and cultural
context, which may or may not have an effect on the measurement properties of
the instrument. This appeals to the possibility to explore and test different
sets of equate items. Also, when in example Figure \@ref(fig:equateex) the first
and second instruments are both administered in the same cohort and the third in
a second, concurrent calibration is not possible for common items in the first
two instruments. In these situations, the equate group method provides a more
flexible way to link items. The equate groups methods works with similar
assumptions as in the concurrent calibration method, but with the flexibility to
explore, test and modify the sets of equate items (i.e. equate groups) used in
the model.



## Requirements of equate groups

Statistical information and subject matter experts form the basis for the
assignment of items to eligible equate groups. In actual modeling, there are
“active” equate groups (i.e. equate groups for which indeed the restriction is
applied) and “passive” equate groups (i.e. similar items for which the
restriction is not applied). Only active groups bridge the different instruments
in the final model.

The following strategies are recommended to be applied to select equate groups:

* As a first step, content experts can start by mapping similar items. For
example use one instrument as a reference and map the items of other instruments
to those items \@ref(sec:mapping).
* In a second step, the mapping can be visualized by plotting the mapped items
in one figure \@ref(sec:viewmapping). That way, potential matches can be
verified and confirmed if they show similar patterns or broken up if they seem
poor matches. In this step, both statistical and content expertise can be
utilized.
* Next, the model can be fitted using a selection of potential matches as active
equate groups. The technical details of this model are explained in
\@ref(sec:statisticalframe). The selection of the final active equate groups for
the model is an iterative process where two important qualifications should be
considered: (1) the active equate groups should link all cohorts and
instruments. (2) To enhance the functioning of equate groups, the active equate
groups are preferably distributed over the scale, rather than centered at one
point.
* The infit and outfit can be calculated for equate groups, which provides a
natural measure of equate group quality \@ref(sec:equatefit).
* The performance of the equategroups across subgroups or cohorts can be tested
with methods designed to detect differential item functioning
\@ref(sec:equatedif).

In general, the use of equate groups is very relevant when the abilities differ
across cohorts. In that case, equate groups are very helpful to place the
abilities across the different cohorts on the same scale. However, when cohort
abilities are relatively uniform and the risk of mis-specification of the equate
groups is high, a model without equate groups would be preferred.


## Statistical framework {#sec:statisticalframe}

The preferred measurement model for development data is the Rasch model. An
introduction of the Rasch model geared towards the $D$-score is described in
https://stefvanbuuren.name/dbook1/. The Rasch model, models the probability of
passing an item as a logistic function of the difference between each person’s
ability and the difficulty of the item, see equation \@ref(eq:rasch).

\begin{equation}
$$\pi_{ni} = \frac{exp(\beta_n - \delta_i)}{1+exp(\beta_n -\delta_i)}$$ (\#eq:rasch)
\end{equation}

Below, the symbols used in the equation \@ref(eq:rasch) are explained.

Symbol        | Term          | Description
------------- | ------------- | -----------
$\beta_n$     | Ability       | True (but unknown) developmental score of child $n$
$\delta_i$    | Difficulty    | True (but unknown) difficulty of an item $i$
$\pi_{ni}$    | Probability   | Probability that child $n$ passes item $i$

The log odds that a person with ability $\beta_n$ answers an item with
difficulty $\delta_i$ correctly is the difference between the person’s ability
and the item’s difficulty $(\beta_n-\delta_i)$ [@wright1982].

In order to facilitate the use of equate groups to link similar items used in
different instruments and cohorts, the Rasch model can be extended. This
extension holds the restriction that item difficulties of similar items are
constrained to be equal. Wright and Masters [@wright1982] present a simple
method to equate the difficulty between two test forms that have common item
links. This is done by estimating the shift in difficulty as the weighted
average of difficulty differences of the linking items, and using this weighted
average to align the difficulties of the test forms. We can use this way of
aligning forms, to align item difficulties of items in an equate group, see
equation \@ref(eq:raschequate).

\begin{equation}
$$\delta_q = \frac{\sum_{l}^{i} \delta_iw_i}{\sum_{l}^{l} w_i}$$ (\#eq:raschequate)
\end{equation}
 
Where $\delta_q$ is the combined difficulty of the items in the equate group,
$\delta_i$ is the difficulty of each item in the equate group and $l$ is the
number of items in the equate group and $w_i$ is the number of respondents that
have an observed score on item $i$.


## Common latent scale

The end goal for using the equate group method to model development items is to
measure development on one common latent scale, the $D$-score. That way, the
measure (i.e. D-score) can be obtained, irrespective of which instrument is used
in which population.

In Figure \@ref(fig:commonscale) the D-scores are displayed for three cohorts
from the GCDG study: Netherlands 1, Ethiopia and Colombia 2. As decribed in
\@ref(sec:cohorts), the Netherlands 1 study contains the DDI, Ethiopia the
Bayley-III, and Colombia the Bayley-III, Denver-II, the ASQ-3 and BDI-2.
Accordingly there is some natural ovelap in items between Ethiopia and Colombia
via the Bayley-III items. However, the Netherlands 1 cohorts is not linked via
the items. In the upper plot, no equate groups were used in the model and
in the lower plot, equate groups linked the cohorts.

```{r commonscale, echo=FALSE, fig.cap=, message=FALSE, warning=FALSE}

#nu in gcdg taal (cohort namen - moet dit naar GSED? - staat al in de gecommente stukken.)
##nu gewoon alleen de drie studies uit volledige 565 model gehaald, klopt niet helemaal met de beschrijving hierboven. Dit moet dus nog worden aangepast / beschrijving of model / maar daarvoor moet eerst een strategie bepaald van hoe we modellen opslaan en inladen in dbook2.
library(ggplot2)
library(ddata)
library(dmetric)
library(gseddata)
library(gridExtra)
## model without equate groups
varlist_o <- prepare_items(study = c("Netherlands 1", "Ethiopia", "Columbia 2"))
sub_items <- rename_gcdg_gsed(varlist_o$items)
varlist <- list(adm = c("subjid", "agedays", "cohort", "cohortn", "subjido"),
                items = sub_items)
sub_lean <- get_data(cohorts = c(43,50,53), items = varlist$items, adm = varlist$adm)

model2 <-  fit_dmodel(varlist, data = sub_lean, equate = NULL,
                    name = "no_equates", age_unit = "years")


#model2$dscore$agedays <- as.integer(model2$dscore$age * 365.25)
#model2$items <- rename_gcdg_gsed(model2$items)
#model2$itembank$lex_gsed <- rename_gcdg_gsed(model2$itembank$lex_gcdg)
#model2$itemtable$item <- rename_gcdg_gsed(model2$itemtable$item)
#rownames(model2$fit$item) <- rename_gcdg_gsed(rownames(model2$fit$item))

#studies_gcdg <- c("Netherlands 1", "Ethiopia", "Columbia 2")
df1 <- model2$dscore %>% mutate(agemos = a*12)

p1 <- ggplot(df1, aes(agemos, d, group=cohort, color=cohort))+
  geom_point()+
  scale_colour_manual(values = gseddata::get_palette("study"), na.value = "grey")+
  xlab("Age (months)")+ylab("D-score") +  
  theme(legend.position =  c(0.8,0.2), legend.title = element_blank())

#model with equate groups
model <- dmetric::model_lean
studies <- c("GCDG-ETH", "GCDG-NLD-SMOCC", "GCDG-COL-LT42M")
df2 <- model$dscore[which(model$dscore$cohort %in% studies),] %>% mutate(agemos = a *12)

#df2$agemos <- df2$agedays/365.25*12
p2 <- ggplot(df2, aes(agemos, d, group=cohort, color=cohort))+
  geom_point()+scale_colour_manual(values = get_palette("study"), na.value = "grey")+ xlab("Age(months)")+ylab("D-score") +  theme(legend.position =  c(0.8,0.2), legend.title = element_blank())

grid.arrange(p1, p2)


```
(ref:commonscale) Example of three cohorts with and without equage group linking.

In the plot for the model without equate groups it can be observed that the
scales for the Ethiopia and Colombia 2 studies are linked naturally via the
shared items from Bayley-III. The Netherlands 1 cohort is not connected and
follows a different track. In the plot for the model with equate groups, the
scales for all three cohorts are connected, due to the links via equate groups.
This example illustrates that the use of equate groups brings the abilities for
children in different cohorts measured with different instrument on one scale.



## Quantifying equate fit {#sec:equatefit}

In the Rasch philosophy it is the task of the data to fit the Rasch model. In
order to verify the fit of the data to the model, we can assess the item fit and
the person fit. Both fit measures are explained thorougly in
https://stefvanbuuren.name/dbook1/ch-evaluation.html. When we use equate groups
in the Rasch model, we can also use these fit indices to determine the fit of
the items in the equate groups.


### Well fitting equate groups

```{r plot_p_d_equate, message=FALSE, warning=FALSE, include=FALSE}
library(gridExtra)
library(dmetric)
library(dscores)
library(ddata)
library(dplyr)
library(tidyr)
##plot p d equate but group for item instead of study.

plot_p_d_equate_i <- function(data,
                            model,
                            equates = NULL,
                            passive = FALSE,
                            metric = "dscore",
                            show_rug = TRUE,
                            show_curve = TRUE,
                            show_fit = TRUE,
                            file = NULL,
                            device = "pdf",
                            ...) {
  lean <- gseddata::is.lean(data)
  model_name <- model$name
  names(model$itembank)[names(model$itembank) == "lex_gsed"] <- "item"

  if (!"agedays" %in% names(data)) {
    data$agedays <- as.integer(data$age / 12 * 365.25)
  }

  # if no equates argument is specified, get equates from the
  # model, find equate groups with at least 2 items in the model
  if (is.null(equates))
    equatelist <- dmetric::get_equates_old(model)

  # if list of equate groups (name with item)
  if (is.list(equates) & length(equates) > 0) equatelist <- equates

  # if names in character vector, get equates subset from model
  if (!is.list(equates) & !is.null(equates))
    equatelist <- model$fit$equate[equates]

  items_eq <- unique(unlist(equatelist))
  items <- intersect(model$items, items_eq)

  # no items left, return
  if (is.null(items)) return()

  # merge data to obtain d
  if (metric == "dscore") {
    modelb <- model$dscore
    colnames(modelb)[colnames(modelb) == "d"] <- "b"
    delta <- dscore::get_tau(model$items, "", model$itembank)
    beta_breaks <- seq(0, 80, 2)
    xlim <- c(0, 80)
    scale <- model$transform[2]
  }

  if (metric == "logit") {
    modelb <- model$beta_l
    delta <- model$fit$item[, "b"]
    names(delta) <- rownames(model$fit$item)
    delta <- delta[items]
    beta_breaks <-
      calculate_logit(seq(0, 80, 2), transform = model$transform)
    xlim <- c(-15, 25)
    scale <- 1
  }

  # merge data to obtain b
  if (!"agedays" %in% names(modelb))
    modelb$agedays <- as.integer(modelb$age * 365.25)
  if (!"study" %in% names(modelb))
    modelb$study <- modelb$cohort
  if (!"id" %in% names(modelb))
    modelb$id <- as.numeric(modelb$subjido)
  modelb <- modelb %>%
    select("study", "id", "agedays", "b")

  if (!lean) {
    if (!"study" %in% names(data))
      data$study <- data$cohort
    if (!"id" %in% names(data))
      data$id <- as.numeric(data$subjido)
    data <- data %>%
      select(one_of(c("study", "id", "agedays", items))) %>%
      pivot_longer(names_to = "item", values_to = "value", cols = -one_of(c("study", "id", "agedays"))) %>%
      drop_na("value", "study", "id", "agedays") %>%
      left_join(modelb, by = c("study", "id", "agedays"))
  }
  if (lean) {
    data <- data$itm %>%
      filter(item %in% items) %>%
      left_join(data$visit, by = c("subjid", "agedays"))%>%
      mutate(id = as.numeric(.data$subjido)) %>%
      left_join(modelb, by = c("id", "agedays"))
  }

  if (!"study" %in% names(data) & !"cohort" %in% names(data))
    data$study <- NA
  if (!"study" %in% names(data) & "cohort" %in% names(data))
    data$study <- data$cohort

  # proportion pass per dscore group
  # observations per months (n) by study and item
  pass <- data %>% filter(item %in% items) %>%
    drop_na("value", "b") %>%
    mutate(dgp = cut(.data$b, breaks = beta_breaks),
           age = .data$agedays / 365.25) %>%
    group_by(study, item, dgp) %>%
    summarise(
      p = round(100 * mean(.data$value, na.rm = TRUE)),
      a = mean(.data$age, na.rm = TRUE),
      b = mean(.data$b, na.rm = TRUE),
      n = n()) %>%
    ungroup() %>%
    left_join(model$itemtable, by = "item") %>%
    arrange(.data$equate, desc(.data$item))

  # define data for rug plot
  data_rug <- NULL
  if (show_rug)
    data_rug <- data %>%
    mutate(age = .data$agedays / 365.25) %>%
    select(one_of(c("study", "item", "age", "value", "b"))) %>%
    group_by(.data$study, .data$item, .data$age, .data$value) %>%
    summarise(b = mean(.data$b, na.rm = TRUE)) %>%
    ungroup() %>%
    left_join(model$itemtable, by = "item")%>% ##added to have instrument variable in rug data
    drop_na("b")

  plots <-
    plot_by_grp_i(
      pass,
      data_rug = data_rug,
      model_name = model_name,
      type = "d",
      metric = metric,
      xlim = xlim,
      package = model$data_package, ...)

  # add logistic curves
  if (show_curve) {
    idx <- match(names(plots), model$itembank$equate)
    location <- model$itembank$tau[idx]
    plots <- dmetric::show_logistic_curve(plots,
                                 location = location,
                                 scale = scale)
  }
  # add equate fit
  if (show_fit)
    plots <- show_equate_fit(plots, model$equate_fit, xlim = xlim)

  # add label signalling ACTIVE equate
  #plots <- show_active_equate(plots, active = model$active_equates)

  # save
  if (!is.null(file) & device == "pdf") {
    pdf(file,
        onefile = TRUE,
        width = 10,
        height = 5)
    lapply(plots, print)
    message("Saved to: ", file)
    dev.off()
  }

  if (!is.null(file) & device == "png") {
    paths <- paste0(file, names(plots), ".png")
    purrr::pwalk(list(filename = paths, plot = plots), ggsave)
  }

  invisible(plots)
}

plot_by_grp_i <- function(pass,
                        by_name = "equate",
                        model_name = "unspecified",
                        quiet = FALSE,
                        type = "d",
                        metric = "dscore", ...) {
  # sort equate groups
  by_grp <- unique(pass$equate)

  # remove missing groups
  if (any(is.na(by_grp))) by_grp <- by_grp[-which(is.na(by_grp))]

  # pre-allocate list of ggplots
  plot_list <- vector("list", length(by_grp))
  names(plot_list) <- by_grp

  # loop over plots
  for (i in seq_along(plot_list)) {
    if (!quiet) cat("Group: ", as.character(i), by_grp[i], "\n")
    if (type == "d") plot_list[[i]] <-
        plot_d_one_grp_i(pass,
                       by_name = by_name, by_value = by_grp[i],
                       i = i, model_name = model_name,
                       metric = metric, ...)
    else plot_list[[i]] <-
        plot_a_one_grp(pass,
                       by_name = by_name, by_value = by_grp[i],
                       i = i, model_name = model_name,
                       metric = metric, ...)
  }

  return(plot_list)
}

plot_d_one_grp_i <- function(pass,
                           data_rug = NULL,
                           by_name,
                           by_value,
                           i = 0,
                           min_n = 10,
                           model_name = "unspecified",
                           metric = "dscore",
                           xlim = c(0,80),
                           package = "gseddata",
                           ...) {
  if (by_name == "item")
    data_plot <- pass %>%
      filter(.data$item == by_value & .data$n >= min_n)

  if (by_name == "equate")
    data_plot <- pass %>%
      filter(.data$equate == by_value & .data$n >= min_n)

  items <- unique(data_plot$item)

  if (!is.null(data_rug) ){
  data_rug <- data_rug %>%
    filter(.data$item %in% items)
  }

  labels <- data_plot$label[match(items, data_plot$item)]
  labels <- substr(labels, 1L, 60L)

  # add study
  if (!"study" %in% names(data_plot))
    data_plot$study <- data_plot$cohort
  if (!"study" %in% names(data_rug))
    data_rug$study <- data_rug$cohort


  if (model_name != "") model_name<- paste("-", model_name)

  plot <- ggplot(data_plot, aes(b, p, group = interaction(study, item),
                                colour = instrument)) + ##_i instrument instead of study
    scale_x_continuous(paste0("Ability (", metric,") ", model_name,""),
                       limits = xlim,
                       breaks = seq(xlim[1], xlim[2], diff(xlim) / 8)) +
    scale_y_continuous("% pass", breaks = seq(0, 100, 10),
                       limits = c(0, 100)) +
    scale_colour_manual(values = dmetric::get_palette("instrument", package = package),
                        na.value = "grey")

  # add rugs
  if (!is.null(data_rug)) {
    if (nrow(data_rug) >= 1)
      plot <- plot +
        geom_rug(aes_string(x = "b", y = "value",
                            group = "instrument", colour = "instrument"),##_i instrument instead of study
                 data = filter(data_rug, .data$value == 0),
                 position = "jitter", sides = "b", size = 0.2) +
        geom_rug(aes_string(x = "b", y = "value",
                            group = "instrument", colour = "instrument"),##_i instrument instead of study
                 data = filter(data_rug, .data$value == 1),
                 position = "jitter", sides = "t", size = 0.2)
  }

  # add proportions
  if (nrow(data_plot) >= 1)
    plot <- plot +
    geom_line() + geom_point()

  # annotations
  plot <- plot +
    theme(legend.position = c(0.99, 0.05), legend.justification = c(1, 0),
          legend.key.size = unit(3.0, "mm"),
          legend.spacing.y = unit(0.5, "mm"),
          legend.background = element_rect(fill = "transparent", colour = "transparent")) +
    guides(fill = guide_legend(title = NULL)) +
    guides(col = guide_legend(ncol = 1)) +
    annotate("text", x = (xlim[1] + 1), y = 2, hjust = 0,
             label = as.character(i)) +
    annotate("text", x = (xlim[1] + 7), y = 2, hjust = 0,
             label = by_value)

  # item nams
  if (length(labels) > 0) {
    for (l in length(labels):1) {
      plot <- plot + annotate("text", x = (xlim[1] + 1), y = 7 + (l - 1) * 5, hjust = 0,
                              label = items[l], family = "Courier", fontface = "bold")
      if (!is.na(labels[l]))
        xfac <- 14
      if (metric == "logit") xfac <- 8
      plot <- plot + annotate("text", x = (xlim[1] + xfac), y = 7 + (l - 1) * 5, hjust = 0,
                              label = labels[l])
    }
  }
  return(plot)
}

show_equate_fit <- function(plot, equate_fit, xlim = c(0, 80)) {
  if (is.null(equate_fit))
    return(plot)
  if (is.ggplot(plot))
    return(annotate_item_fit(plot, itemfit = equate_fit))
  if (is.list(plot)) {
    for (i in seq_along(plot)) {
      the_name <- names(plot)[i]
      itemfit <- filter(equate_fit, equate == the_name)
      if (nrow(itemfit) == 1) plot[[i]] <-
        annotate_item_fit(plot[[i]], itemfit = itemfit, xlim = xlim)
    }
  }
  return(plot)
}

show_active_equate <- function(plot, active) {
  # active: vector of names of active equate groups
  # if (is.ggplot(plot)) return(annotate_active_equate(plot))
  #if (is.list(plot)) {
    for (i in seq_along(plot)) {
      the_name <- names(plot)[i]
      if (the_name %in% active)
        plot[[i]] <- annotate_active_equate(plot[[i]])
    }
  #}
  return(plot)
}

annotate_item_fit <- function(plot, itemfit, pole = TRUE, xlim=c(0,80)) {
  # function assumes that location is scalar and plot is ggplot
  if (!is.ggplot(plot)) stop("Argument plot not a ggplot.")
  if (is.na(itemfit[1])) return(plot)
  if (pole) {
    plot <- plot +
      annotate("text", x = (xlim[1]+1), y = 97, hjust = 0,
               label = paste0("Outfit ",
                              round(itemfit$outfit, 2),
                              "(",
                              round(itemfit$outfit_z, 2),
                              ")"))
    plot <- plot +
      annotate("text", x = (xlim[1]+1), y = 92, hjust = 0,
               label = paste0("Infit  ",
                              round(itemfit$infit, 2),
                              "(",
                              round(itemfit$infit_z, 2),
                              ")"))
  }
  else {
    plot <- plot +
      annotate("text", x = (xlim[1]+1), y = 82, hjust = 0,
               label = paste0("Outfit ",
                              round(itemfit$outfit, 2),
                              "(",
                              round(itemfit$outfit_z, 2),
                              ")"))
    plot <- plot +
      annotate("text", x = (xlim[1]+1), y = 77, hjust = 0,
               label = paste0("Infit  ",
                              round(itemfit$infit, 2),
                              "(",
                              round(itemfit$infit_z, 2),
                              ")"))
  }
  plot
}

```

The study of *equate fit* involves comparing the observed probabilities of
endorsing the items in the equate group to the estimated probability of
endorsing the items in the equate group. In an equate group there is an
empirical curve for each item in the equate group and one shared estimated
curve. The empirical curves should all be close to the estimiated curve for a
good equate fit, presented in the two examples in Figure \@ref(fit:ploteqfit).

```{r ploteqfit, results = 'hide', fig.keep = 'all', fig.height = 11, warning = FALSE, fig.cap = '(ref:ploteqfit)', message = FALSE}
ps <- plot_p_d_equate_i(data = dmetric::gcdg_lean , model = dmetric::model_lean)
grid.arrange(ps[["REC6"]], ps[["GM42"]])
```
(ref:ploteqfit) Two equate groups that present a good equate fit.

The equate item *Turns head to sound of bell* is asked in slightly different formats in the Bayley I (by1), Dutch Development Instrument (ddi) and the Denver (den). The three items are combined in an equate group and the empirical data is clored differently for each instrument in Figure \@ref(fit:ploteqfit). The empirical data for each instrument is close to the fitted dashed line, which indicates a good equate fit. Equate item *Walks alone* is administered in six different instruments (bar, by1, by2, by3, ddi and gri).

### Equate groups with poor equate fit

<!-- Hier een ouder model pakken, waar nog slechtere equate groups bij zitten. En daar een plot van weergeven.  -->
```{r ploteqfit, results = 'hide', fig.keep = 'all', fig.height = 11, warning = FALSE, fig.cap = '(ref:ploteqfit)', message = FALSE}
load_model <-function(model_name) {
     path <-  "C://Users/eekhouti/Dropbox/models"
     fn <- file.path(path, model_name, "model.Rds")
     readRDS(fn)
   }
#path <- "C://Users/eekhouti/Dropbox/models"

poor_model <- load_model("667_19_SA")
names(poor_model$itembank)[names(poor_model$itembank)=="lex.gcdg"] <- "item"
poor_model$fit$equate<- lapply(poor_model$fit$equate, rename_gcdg_gsed)
poor_model$items <- rename_gcdg_gsed(poor_model$items)
poor_model$itembank$item <- rename_gcdg_gsed(poor_model$itembank$item)
poor_model$data_package <- "gseddata"
poor_model$itemtable <- gseddata::get_itemtable(items = poor_model$items)
#refit model with extracted settings from model?

ps_poor <- plot_p_d_equate_i(data = dmetric::gcdg_lean , model = poor_model, passive = TRUE, file = "C:\\Users\\eekhouti\\Desktop\\poor_equates.pdf")
ps_poor[["COG56"]]
ps_poor[["EXP20"]]
ps_poor[["GM43"]]

grid.arrange(ps_poor[["COG56"]], ps_poor[["EXP20"]])









```
(ref:ploteqfit) Two equate groups that present a good equate fit.


## Differential item functioning {#sec:equatedif}

An important assumption underlying equate groups is that the items in the group
work in the same way across the different cohorts, i.e., there is no
differential item functioning. This assumption is critical for active equate
groups. If it is not met, restricting the difficulty parameters to be equal
across cohorts may introduce unwanted bias in comparisons between cohorts.


>>voorbeeld van goede en slechte equate group to show DIF in equate groups.

### Good equate group without DIF

```{r plotnoeqdif, results = 'hide', fig.keep = 'all', fig.height = 11, warning = FALSE, fig.cap = '(ref:plotnoeqdif)', message = FALSE}
model <- dmetric::model_lean
names(model$itembank)[names(model$itembank) == "lex_gsed"] <- "item"
pdif <- dmetric::plot_p_d_equate(data = dmetric::gcdg_lean , model =model, passive = TRUE)
grid.arrange(pdif[["FM31"]], pdif[["EXP26"]])

```
(ref:plotnoeqdif) Two equate groups that present no differiential item functioning within the equate group.


### Poor equate groups with DIF for study


```{r ploteqdif, results = 'hide', fig.keep = 'all', fig.height = 11, warning = FALSE, fig.cap = '(ref:ploteqdif)', message = FALSE}

grid.arrange(pdif[["GM44"]], pdif[["EXP23"]])

```
(ref:ploteqdif) Two equate groups that present differiential item functioning for study within the equate group.

