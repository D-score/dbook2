# Equate groups {#ch:equategroups}

This chapter explains the equate group method. The equate group method is a
novel method to link different instruments administered across multiple cohorts.
Combining existing data sets for meta-analyses enables analyses across multiple
contexts and conditions. 

* Definition of equate groups (\@ref(sec:eqdef))
* Concurrent calibration (\@ref(sec:concurrent))
* Requirements of equate groups (\@ref(sec:equaterules))
* Statistical framework (\@ref(sec:statisticalframe))
* Common latent scale (\@ref(sec:commonscale))
* Quantifying equate fit (\@ref(sec:equatefit))
* Differential Item Functioning (\@ref(sec:equatedif))

## Definition of equate groups {#sec:eqdef}

A group of items that measure the same thing in (perhaps slightly) different
ways is called an “equate group”. An equate group can link items across
instruments by restricting their difficulty estimates to be identical. Equate
groups provide an extra option for bridging different instruments to the same
scale. Figure \@ref(fig:equateex) displays items from three different
instruments that measure child development. The instruments contain some common
items that are measured in multiple instruments, but also unique items. The
common items can be linked in an equate group as displayed by the arrows between
them. In the example there is one (common) item that is equivalent in all three
instruments (i.e. walk alone). The item "sitting" occurs in both the first (i.e.
blue) and the second (i.e. green) instrument and the item "clabs hand together"
occurs in the second (i.e. green) and third (i.e. orange instrument).

```{r equateex, fig.cap = '(ref:equateex)'}
knitr::include_graphics("fig/equate_ex.png")
```
(ref:equateex) Example of three instruments that are bridged by common items in equate groups.

## Concurrent calibration {#sec:concurrent}

When each instrument is administered in a different cohort, the cohorts can be
linked by placing the common items in the same column. The common items will
have the same difficulty estimates due to linking with "concurrent calibration".
In concurrent calibration the item parameters for all instruments are estimated
simulateously. Concurrent calibration is an attractive option, however this
method warrants a strict distinction between items that are truly the same in
different instruments and items that differ. In practice, items that measure the
same skill may have been adapted to suit the format of the instrument (e.g.
number of response options, question formulation, and so on) or to suit the
local language and cultural context, which may or may not have an effect on the
measurement properties of the instrument. This appeals to the possibility to
explore and test different sets of equate items. Also, when in example Figure
\@ref(fig:equateex) the first and second instruments are both administered in
the same cohort and the third in a second, concurrent calibration is not
possible for common items in the first two instruments. In these situations, the
equate group method is a more flexible way to link items. The equate groups
methods works with similar assumptions as the concurrent calibration method, but
with the flexibility to explore, test and modify the sets of equate items (i.e.
equate groups) used in the model.



## Requirements of equate groups {#sec:equaterules}

Statistical information and subject matter experts form the basis for the
assignment of items to eligible equate groups. In actual modeling, there are
“active” equate groups (i.e. equate groups for which the restriction is actually
applied) and “passive” equate groups (i.e. similar items for which the
restriction is not applied). Only active groups bridge the different instruments
in the final model.

The following strategies are recommended to select equate groups:

* As a first step, content experts can start by mapping similar items. For
example use one instrument as a reference and map the items of other instruments
to those items (see section \@ref(sec:mapping)).
* In a second step, the mapping can be visualized by plotting the mapped items
in one figure (see section \@ref(sec:viewmapping)). That way, potential matches
can be verified and confirmed if they show similar patterns or broken up if they
seem poor mappings. In this step, both statistical and content expertise can be
utilized.
* Next, the model can be fitted using a selection of potential matches as active
equate groups. The technical details of this model are explained in section
\@ref(sec:statisticalframe). The selection of the final active equate groups for
the model is an iterative process where two important qualifications should be
considered: (1) the active equate groups should link all cohorts and
instruments. (2) To enhance the functioning of equate groups, the active equate
groups are preferably distributed over the scale, rather than centered at one
point.
* The infit and outfit can be calculated for equate groups, which provides a
natural measure of equate group quality (see section \@ref(sec:equatefit)).
* The performance of the equategroups across subgroups or cohorts can be tested
with methods designed to detect differential item functioning (see section
\@ref(sec:equatedif)).

In general, the use of equate groups is very relevant when the abilities differ
across cohorts. In that case, equate groups are very helpful to place the
abilities across the different cohorts on the same scale. However, when cohort
abilities are relatively uniform and the risk of mis-specification of the equate
groups is high, a model without equate groups is preferred.


## Statistical framework {#sec:statisticalframe}

The preferred measurement model for development data is the Rasch model. An
introduction of the Rasch model geared towards the $D$-score is described in
https://stefvanbuuren.name/dbook1/. The Rasch model, models the probability of
passing an item as a logistic function of the difference between each person’s
ability and the difficulty of the item, see equation \@ref(eq:rasch).

\begin{equation}
\pi_{ni} = \frac{exp(\beta_n - \delta_i)}{1+exp(\beta_n -\delta_i)} (\#eq:rasch)
\end{equation}

The symbols used in equation \@ref(eq:rasch) are explained in Table
\@ref(tab:symbols). The log odds that a person with ability $\beta_n$ answers an
item with difficulty $\delta_i$ correctly is the difference between the person’s
ability and the item’s difficulty $(\beta_n-\delta_i)$ [@wright1982].

In order to facilitate the use of equate groups to link similar items used in
different instruments and cohorts, the Rasch model can be extended. This
extension holds the restriction that item difficulties of similar items are
constrained as equal. Wright and Masters [@wright1982] present a simple method
to equate the difficulty between two test forms that have common item links.
This is done by estimating the shift in difficulty as the weighted average of
difficulty differences of the linked items, and using this weighted average to
align the difficulties of the test forms. We can use this way of aligning forms,
to align item difficulties of items in an equate group, see equation
\@ref(eq:raschequate).

\begin{equation}
\delta_q = \frac{\sum_{l}^{i} \delta_iw_i}{\sum_{l}^{l} w_i} (\#eq:raschequate)
\end{equation}
 

Symbol | Term  | Description
------------- | ------------- | -----------
$\beta_n$     | Ability       | True (but unknown) developmental score of child $n$
$\delta_i$    | Difficulty    | True (but unknown) difficulty of item $i$
$\delta_q$    | Difficulty    | The combined difficulty of the items in equate group $q$
$\pi_{ni}$    | Probability   | Probability that child $n$ passes item $i$
$l$           |               | The number of items in the equate group
$w_i$         |               | The number of respondends with an observed score on item $i$

: (\#tab:symbols) Overview the symbols used in equations \@ref(eq:rasch) and \@ref(eq:raschequate).

## Common latent scale {#sec:commonscale}

The end goal for using the equate group method to model development items is to
measure development on one common latent scale, the $D$-score. That way, the
measure (i.e. $D$-score) can be obtained, irrespective of which instrument is
used in which population.

In Figure \@ref(fig:commonscale) the $D$-scores are displayed for three cohorts
from the GCDG study: Netherlands 1 (GCDG-NLS-SMOCC), Ethiopia (GCDG-ETH) and
Colombia 2 (GCDG-COL-LT42M). As decribed in section \@ref(sec:cohorts), the
Netherlands 1 study contains the ddi; Ethiopia the by3; and Colombia the by3,
den, asq and bdi. Accordingly there is some natural ovelap in items between
Ethiopia and Colombia via the by3 items. However, the Netherlands 1 cohorts is
not linked via the items. In the upper plot, no equate groups were used in the
model and in the lower plot, equate groups linked the cohorts.

```{r commonscale, echo=FALSE, fig.cap='(ref:commonscale)', message=FALSE, warning=FALSE, cache = TRUE}
library(ggplot2)
library(dmetric)
library(gseddata)
library(gridExtra)
library(dplyr)

## model without equate groups
varlist_o <- dmetric::prepare_items(study = c("Netherlands 1", "Ethiopia", "Columbia 2"))
sub_items <- rename_gcdg_gsed(varlist_o$items)
varlist <- list(adm = c("subjid", "agedays", "cohort", "cohortn", "subjido"),
                items = sub_items)
sub_lean <- gseddata::get_data(cohorts = c(43,50,53), items = varlist$items, adm = varlist$adm)
model2 <-  fit_dmodel(varlist, data = sub_lean, equate = NULL,
                      name = "no_equates", age_unit = "years")

df1 <- model2$dscore %>% mutate(agemos = a*12)

p1 <- ggplot(data = df1) +  
  geom_point(aes(agemos, d, group=cohort, color=cohort)) +
  scale_colour_manual(values = gseddata::get_palette("study"), na.value = "grey")+
  xlab("Age (months)")+
  ylab("D-score") +  
  theme(legend.position =  c(0.8,0.2), legend.title = element_blank())

#model with equate groups
model <- dmetric::model_lean
studies <- c("GCDG-ETH", "GCDG-NLD-SMOCC", "GCDG-COL-LT42M")
df2 <- model$dscore[which(model$dscore$cohort %in% studies),] %>% mutate(agemos = a *12)

p2 <- ggplot(data = df2)+
  geom_point( aes(agemos, d, group=cohort, color=cohort))+
  scale_colour_manual(values = get_palette("study"), na.value = "grey")+ 
  xlab("Age(months)")+
  ylab("D-score") +  
  theme(legend.position =  c(0.8,0.2), legend.title = element_blank())

grid.arrange(p1, p2)


```
(ref:commonscale) Example of three cohorts with and without equage group linking.

In the plot for the model without equate groups it can be observed that the
scales for the Ethiopia and Colombia 2 studies are linked naturally via the
shared items from by3. The Netherlands 1 cohort is not connected and follows a
different track. In the plot for the model with equate groups, the scales for
all three cohorts are connected. This example shows that the use of equate
groups brings the abilities for children in different cohorts measured with
different instrument on one scale.


## Quantifying equate fit {#sec:equatefit}

In the Rasch philosophy it is the task of the data to fit the Rasch model. In
order to verify the fit of the data to the model, we can assess the item fit and
the person fit. Both fit measures are explained thorougly in
https://stefvanbuuren.name/dbook1/ch-evaluation.html. When we use equate groups
in the Rasch model, we can also use these fit indices to determine the fit of
the items in the equate groups.


### Well fitting equate groups

```{r plot_p_d_equate, message=FALSE, warning=FALSE, include=FALSE}
library(gridExtra)
library(dmetric)
library(dscore)
library(ddata)
library(dplyr)
library(tidyr)
##plot p d equate but group for item instead of study.

plot_p_d_equate_i <- function(data,
                            model,
                            equates = NULL,
                            passive = FALSE,
                            metric = "dscore",
                            show_rug = TRUE,
                            show_curve = TRUE,
                            show_fit = TRUE,
                            file = NULL,
                            device = "pdf",
                            ...) {
  lean <- gseddata::is.lean(data)
  model_name <- model$name
  names(model$itembank)[names(model$itembank) == "lex_gsed"] <- "item"

  if (!"agedays" %in% names(data)) {
    data$agedays <- as.integer(data$age / 12 * 365.25)
  }

  # if no equates argument is specified, get equates from the
  # model, find equate groups with at least 2 items in the model
  if (is.null(equates))
    equatelist <- dmetric::get_equates(model)

  # if list of equate groups (name with item)
  if (is.list(equates) & length(equates) > 0) equatelist <- equates

  # if names in character vector, get equates subset from model
  if (!is.list(equates) & !is.null(equates))
    equatelist <- model$fit$equate[equates]

  items_eq <- unique(unlist(equatelist))
  items <- intersect(model$items, items_eq)

  # no items left, return
  if (is.null(items)) return()

  # merge data to obtain d
  if (metric == "dscore") {
    modelb <- model$dscore
    colnames(modelb)[colnames(modelb) == "d"] <- "b"
    delta <- dscore::get_tau(model$items, "", model$itembank)
    beta_breaks <- seq(0, 80, 2)
    xlim <- c(0, 80)
    scale <- model$transform[2]
  }

  if (metric == "logit") {
    modelb <- model$beta_l
    delta <- model$fit$item[, "b"]
    names(delta) <- rownames(model$fit$item)
    delta <- delta[items]
    beta_breaks <-
      calculate_logit(seq(0, 80, 2), transform = model$transform)
    xlim <- c(-15, 25)
    scale <- 1
  }

  # merge data to obtain b
  if (!"agedays" %in% names(modelb))
    modelb$agedays <- as.integer(modelb$age * 365.25)
  if (!"study" %in% names(modelb))
    modelb$study <- modelb$cohort
  if (!"id" %in% names(modelb))
    modelb$id <- as.numeric(modelb$subjido)
  modelb <- modelb %>%
    select("study", "id", "agedays", "b")

  if (!lean) {
    if (!"study" %in% names(data))
      data$study <- data$cohort
    if (!"id" %in% names(data))
      data$id <- as.numeric(data$subjido)
    data <- data %>%
      select(one_of(c("study", "id", "agedays", items))) %>%
      pivot_longer(names_to = "item", values_to = "value", cols = -one_of(c("study", "id", "agedays"))) %>%
      drop_na("value", "study", "id", "agedays") %>%
      left_join(modelb, by = c("study", "id", "agedays"))
  }
  if (lean) {
    data <- data$itm %>%
      filter(item %in% items) %>%
      left_join(data$visit, by = c("subjid", "agedays"))%>%
      mutate(id = as.numeric(.data$subjido)) %>%
      left_join(modelb, by = c("id", "agedays"))
  }

  if (!"study" %in% names(data) & !"cohort" %in% names(data))
    data$study <- NA
  if (!"study" %in% names(data) & "cohort" %in% names(data))
    data$study <- data$cohort

  # proportion pass per dscore group
  # observations per months (n) by study and item
  pass <- data %>% filter(item %in% items) %>%
    drop_na("value", "b") %>%
    mutate(dgp = cut(.data$b, breaks = beta_breaks),
           age = .data$agedays / 365.25) %>%
    group_by(study, item, dgp) %>%
    summarise(
      p = round(100 * mean(.data$value, na.rm = TRUE)),
      a = mean(.data$age, na.rm = TRUE),
      b = mean(.data$b, na.rm = TRUE),
      n = n()) %>%
    ungroup() %>%
    left_join(model$itemtable, by = "item") %>%
    arrange(.data$equate, desc(.data$item))

  # define data for rug plot
  data_rug <- NULL
  if (show_rug)
    data_rug <- data %>%
    mutate(age = .data$agedays / 365.25) %>%
    select(one_of(c("study", "item", "age", "value", "b"))) %>%
    group_by(.data$study, .data$item, .data$age, .data$value) %>%
    summarise(b = mean(.data$b, na.rm = TRUE)) %>%
    ungroup() %>%
    left_join(model$itemtable, by = "item")%>% ##added to have instrument variable in rug data
    drop_na("b")

  plots <-
    plot_by_grp_i(
      pass,
      data_rug = data_rug,
      model_name = model_name,
      type = "d",
      metric = metric,
      xlim = xlim,
      package = model$data_package, ...)

  # add logistic curves
  if (show_curve) {
    idx <- match(names(plots), model$itembank$equate)
    location <- model$itembank$tau[idx]
    plots <- dmetric::show_logistic_curve(plots,
                                 location = location,
                                 scale = scale)
  }
  # add equate fit
  if (show_fit)
    plots <- show_equate_fit(plots, model$equate_fit, xlim = xlim)

  # add label signalling ACTIVE equate
  #plots <- show_active_equate(plots, active = model$active_equates)

  # save
  if (!is.null(file) & device == "pdf") {
    pdf(file,
        onefile = TRUE,
        width = 10,
        height = 5)
    lapply(plots, print)
    message("Saved to: ", file)
    dev.off()
  }

  if (!is.null(file) & device == "png") {
    paths <- paste0(file, names(plots), ".png")
    purrr::pwalk(list(filename = paths, plot = plots), ggsave)
  }

  invisible(plots)
}

plot_by_grp_i <- function(pass,
                        by_name = "equate",
                        model_name = "unspecified",
                        quiet = FALSE,
                        type = "d",
                        metric = "dscore", ...) {
  # sort equate groups
  by_grp <- unique(pass$equate)

  # remove missing groups
  if (any(is.na(by_grp))) by_grp <- by_grp[-which(is.na(by_grp))]

  # pre-allocate list of ggplots
  plot_list <- vector("list", length(by_grp))
  names(plot_list) <- by_grp

  # loop over plots
  for (i in seq_along(plot_list)) {
    if (!quiet) cat("Group: ", as.character(i), by_grp[i], "\n")
    if (type == "d") plot_list[[i]] <-
        plot_d_one_grp_i(pass,
                       by_name = by_name, by_value = by_grp[i],
                       i = i, model_name = model_name,
                       metric = metric, ...)
    else plot_list[[i]] <-
        plot_a_one_grp(pass,
                       by_name = by_name, by_value = by_grp[i],
                       i = i, model_name = model_name,
                       metric = metric, ...)
  }

  return(plot_list)
}

plot_d_one_grp_i <- function(pass,
                           data_rug = NULL,
                           by_name,
                           by_value,
                           i = 0,
                           min_n = 10,
                           model_name = "unspecified",
                           metric = "dscore",
                           xlim = c(0,80),
                           package = "gseddata",
                           ...) {
  if (by_name == "item")
    data_plot <- pass %>%
      filter(.data$item == by_value & .data$n >= min_n)

  if (by_name == "equate")
    data_plot <- pass %>%
      filter(.data$equate == by_value & .data$n >= min_n)

  items <- unique(data_plot$item)

  if (!is.null(data_rug) ){
  data_rug <- data_rug %>%
    filter(.data$item %in% items)
  }

  labels <- data_plot$label[match(items, data_plot$item)]
  labels <- substr(labels, 1L, 60L)

  # add study
  if (!"study" %in% names(data_plot))
    data_plot$study <- data_plot$cohort
  if (!"study" %in% names(data_rug))
    data_rug$study <- data_rug$cohort


  if (model_name != "") model_name<- paste("-", model_name)

  plot <- ggplot(data_plot, aes(b, p, group = interaction(study, item),
                                colour = instrument)) + ##_i instrument instead of study
    scale_x_continuous(paste0("Ability (", metric,") ", model_name,""),
                       limits = xlim,
                       breaks = seq(xlim[1], xlim[2], diff(xlim) / 8)) +
    scale_y_continuous("% pass", breaks = seq(0, 100, 10),
                       limits = c(0, 100)) +
    scale_colour_manual(values = dmetric::get_palette("instrument", package = package),
                        na.value = "grey")

  # add rugs
  if (!is.null(data_rug)) {
    if (nrow(data_rug) >= 1)
      plot <- plot +
        geom_rug(aes_string(x = "b", y = "value",
                            group = "instrument", colour = "instrument"),##_i instrument instead of study
                 data = filter(data_rug, .data$value == 0),
                 position = "jitter", sides = "b", size = 0.2) +
        geom_rug(aes_string(x = "b", y = "value",
                            group = "instrument", colour = "instrument"),##_i instrument instead of study
                 data = filter(data_rug, .data$value == 1),
                 position = "jitter", sides = "t", size = 0.2)
  }

  # add proportions
  if (nrow(data_plot) >= 1)
    plot <- plot +
    geom_line() + geom_point()

  # annotations
  plot <- plot +
    theme(legend.position = c(0.99, 0.05), legend.justification = c(1, 0),
          legend.key.size = unit(3.0, "mm"),
          legend.spacing.y = unit(0.5, "mm"),
          legend.background = element_rect(fill = "transparent", colour = "transparent")) +
    guides(fill = guide_legend(title = NULL)) +
    guides(col = guide_legend(ncol = 1)) +
    annotate("text", x = (xlim[1] + 1), y = 2, hjust = 0,
             label = as.character(i)) +
    annotate("text", x = (xlim[1] + 7), y = 2, hjust = 0,
             label = by_value)

  # item nams
  if (length(labels) > 0) {
    for (l in length(labels):1) {
      plot <- plot + annotate("text", x = (xlim[1] + 1), y = 7 + (l - 1) * 5, hjust = 0,
                              label = items[l], family = "Courier", fontface = "bold")
      if (!is.na(labels[l]))
        xfac <- 14
      if (metric == "logit") xfac <- 8
      plot <- plot + annotate("text", x = (xlim[1] + xfac), y = 7 + (l - 1) * 5, hjust = 0,
                              label = labels[l])
    }
  }
  return(plot)
}

show_equate_fit <- function(plot, equate_fit, xlim = c(0, 80)) {
  if (is.null(equate_fit))
    return(plot)
  if (is.ggplot(plot))
    return(annotate_item_fit(plot, itemfit = equate_fit))
  if (is.list(plot)) {
    for (i in seq_along(plot)) {
      the_name <- names(plot)[i]
      itemfit <- filter(equate_fit, equate == the_name)
      if (nrow(itemfit) == 1) plot[[i]] <-
        annotate_item_fit(plot[[i]], itemfit = itemfit, xlim = xlim)
    }
  }
  return(plot)
}

show_active_equate <- function(plot, active) {
  # active: vector of names of active equate groups
  # if (is.ggplot(plot)) return(annotate_active_equate(plot))
  #if (is.list(plot)) {
    for (i in seq_along(plot)) {
      the_name <- names(plot)[i]
      if (the_name %in% active)
        plot[[i]] <- annotate_active_equate(plot[[i]])
    }
  #}
  return(plot)
}

annotate_item_fit <- function(plot, itemfit, pole = TRUE, xlim=c(0,80)) {
  # function assumes that location is scalar and plot is ggplot
  if (!is.ggplot(plot)) stop("Argument plot not a ggplot.")
  if (is.na(itemfit[1])) return(plot)
  if (pole) {
    plot <- plot +
      annotate("text", x = (xlim[1]+1), y = 97, hjust = 0,
               label = paste0("Outfit ",
                              round(itemfit$outfit, 2),
                              "(",
                              round(itemfit$outfit_z, 2),
                              ")"))
    plot <- plot +
      annotate("text", x = (xlim[1]+1), y = 92, hjust = 0,
               label = paste0("Infit  ",
                              round(itemfit$infit, 2),
                              "(",
                              round(itemfit$infit_z, 2),
                              ")"))
  }
  else {
    plot <- plot +
      annotate("text", x = (xlim[1]+1), y = 82, hjust = 0,
               label = paste0("Outfit ",
                              round(itemfit$outfit, 2),
                              "(",
                              round(itemfit$outfit_z, 2),
                              ")"))
    plot <- plot +
      annotate("text", x = (xlim[1]+1), y = 77, hjust = 0,
               label = paste0("Infit  ",
                              round(itemfit$infit, 2),
                              "(",
                              round(itemfit$infit_z, 2),
                              ")"))
  }
  plot
}

```

The evaluation of *equate fit* involves comparing the observed probabilities of
endorsing the items in the equate group to the estimated probability of
endorsing the items in the equate group. In an equate group there is an
empirical curve for each item in the equate group and one shared estimated
curve. The empirical curves should all be close to the estimiated curve for a
good equate fit, as presented in the two examples in Figure
\@ref(fig:ploteqfit).

```{r ploteqfit, results = 'hide', fig.keep = 'all', fig.height = 11, warning = FALSE, fig.cap = '(ref:ploteqfit)', message = FALSE}
ps <- plot_p_d_equate_i(data = dmetric::gcdg_lean , model = dmetric::model_lean)
grid.arrange(ps[["REC6"]], ps[["GM42"]])
```
(ref:ploteqfit) Two equate groups that present a good equate fit.

The equate *Turns head to sound of bell* is asked in slightly different
formats in the Bayley I (by1), Dutch Development Instrument (ddi) and the Denver
(den). The three items are combined in an equate group and the empirical data
are clored differently for each instrument in Figure \@ref(fig:ploteqfit).
Equate *Walks alone* is administered in six different instruments (bar,
by1, by2, by3, ddi and gri). For both equate groups, the empirical data for each
instrument is close to the fitted dashed line, which indicates a good equate
fit. The infit and outfit indices, shown in Figure\@ref(fig:ploteqfit), confirm
the good fit (fit < 1).

### Equate groups with poor equate fit

In modeling with equate groups, selecting the perfect combination of equate
groups is a crucial step. Poor fitting equate groups need to be set as passive
equate groups, such that the items in the group are not restricted to the same
difficulty anymore. In a poor fitting equate group the empirical curve for each
item in the equate group are not close to the shared estimated curve.
Additionally, the fit indices show poor fit as well (fit > 1). Two examples of
poor equate fit are shown in Figure \@ref(fig:ploteqpoor).

```{r ploteqpoor, results = 'hide', fig.keep = 'all', fig.height = 11, warning = FALSE, fig.cap = '(ref:ploteqpoor)', message = FALSE, cache = TRUE}

varlist <- list(adm = c("subjid", "agedays", "cohort", "subjido"),
                items = gseddata::gcdg_items)
equatelist_poor <- gseddata::gcdg_equatelist
equatelist_poor$COG24 <- c("by1mdd066", "denfmd013")
#equatelist_poor$GM45 <- c("ddigmd070", "grigmd208")
#equatelist_poor$EXP23 <- c("barxxx014", "denlgd017", "grihsd213")
equatelist_poor$EXP12 <- c("by1mdd101", "ddicmm034", "grihsd011")
model_poor <- fit_dmodel(varlist, data = dmetric::gcdg_lean, equate = equatelist_poor,
                    name = "", age_unit = "years")

psp <- plot_p_d_equate_i(data = dmetric::gcdg_lean, model = model_poor)

grid.arrange(psp[["COG24"]], psp[["EXP12"]])
```
(ref:ploteqpoor) Two equate groups that present a poor equate fit.

The equate *Bangs in play / Bangs 2 blocks* is asked in two different
instruments, the Bayley I (by1) and the Denver (den). The empricial curve for
the Bayley I item is not close to the fitted curve. The fitted curve is closer
to the Denver item, which suggests that the equate difficulty is mostly based on
the Denver item data. The fit indices are both larger than 1 also indicating the
poor fit. The equate *Jabbers expressively* is asked in different forms in three
instruments (i.e. by1, ddi, and gri). The empirical curves, with different
colors for ech instrument, are not close to each other, nor close to the fitted
curve. Also for this equate the fit indices confirm the poor fit (fit > 1). Both
equates should be deactivated in an updated model.

## Differential item functioning {#sec:equatedif}

An important assumption for equate groups is that the items in the group work in
the same way across the different cohorts, i.e., there is no differential item
functioning. This means that the items in the equate group are equally difficult
for children in different cohorts. This assumption is critical for active equate
groups. If it is not met, restricting the difficulty parameters as equal across
cohorts may introduce unwanted bias in comparisons between cohorts.


### Good equate group without DIF

In Figure \@ref(fig:plotnoeqdif), two active equate groups are displayed with
empirical curves in different colors for each cohort. In both equate groups the
curves are close to each other and to the fitted dashed curve. The lack of
difference between the curves for the differnt cohorts, shows that there is no
different equate functioning (i.e. different item functioning, DIF) between the
cohorts.

```{r plotnoeqdif, results = 'hide', fig.keep = 'all', fig.height = 11, warning = FALSE, fig.cap = '(ref:plotnoeqdif)', message = FALSE}

pdif <- dmetric::plot_p_d_equate(data = dmetric::gcdg_lean , model =dmetric::model_lean, passive = TRUE, show_fit = FALSE)
grid.arrange(pdif[["FM31"]], pdif[["EXP26"]])

```
(ref:plotnoeqdif) Two equate groups that present no differential item functioning between cohorts.


### Poor equate groups with DIF for study

In Figure \@ref(fig:ploteqdif), two passive equate groups are displayed, that
show differential item functioning between cohorts. The empirical curves are
displayed for each cohort separately in different colors. The difference between
these curves shows the differential item functioning. For example, the item
*Throws ball*, is easier for children in the South-Africa cohort (purple curve;
GCDG-ZAF), and more difficult for children in Colombia (blue curve;
GCDG-COL-LT42M). In other words, the probability to pass the item given the
D-score (i.e. item difficulty) differs between the cohorts. The same goes for
the item *Says more than 5 words*, which is easier for childen in Jamaica
(yellow and pink curves; GCDG-JAM-LBW and GCDG-JAM-SUNTED) and more difficult for
children in Ecuador (green; GCDG-ECU).

```{r ploteqdif, results = 'hide', fig.keep = 'all', fig.height = 11, warning = FALSE, fig.cap = '(ref:ploteqdif)', message = FALSE}

grid.arrange(pdif[["GM44"]], pdif[["EXP23"]])

```
(ref:ploteqdif) Two equate groups that present differential item functioning between cohorts.

