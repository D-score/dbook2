```{r ch4libs, include=FALSE}
library(ggplot2)
library(dmetric)
library(gseddata)
library(gridExtra)
library(dplyr)
library(dscore)
library(ddata)
library(tidyr)

```

# Equate groups {#ch:equategroups}

This chapter introduces the concepts and tools needed to link assessments made by different instruments administered across multiple cohorts. Our methodology introduces the idea of an equate group. Systematic application of equate groups provides a robust yet flexible methodology to link different instruments. Once the links are in place, we may combine the data to enable meta-analyses and related methods.

* What is an equate group? (\@ref(sec:eqdef))
* Concurrent calibration (\@ref(sec:concurrent))
* Strategy to form and test equate groups (\@ref(sec:equaterules))
* Statistical framework (\@ref(sec:statisticalframe))
* Common latent scale (\@ref(sec:commonscale))
* Quantifying equate fit (\@ref(sec:equatefit))
* Differential Item Functioning (\@ref(sec:equatedif))

## What is an equate group? {#sec:eqdef}

An *equate group* is a set of two or more milestones that measure the same thing in (perhaps slightly) different ways. Table \@ref(tab:example2words) contains an example of an equate group, containing items that measure the ability to form two-word sentences. Also, Figures \@ref(fig:poteq) and \@ref(fig:badeq) show examples of equate groups. 

Equate groups vary in quality. We can use high-quality equate groups to link instruments by restricting the difficulty of all milestones in the equate group to be identical. Equate groups thus provide a method for bridging different tools.

```{r equateex, echo=FALSE, fig.cap='(ref:equateex)', fig.height=6}
knitr::include_graphics("fig/equate_ex.png")
```
(ref:equateex) Example of three instruments that are bridged by common items in equate groups.

Figure \@ref(fig:equateex) displays items from three different instruments with overlapping sets of milestones. The shared items make up equate groups, as displayed by the arrows between them. In the example, all three instruments share one milestone ("walk alone"). The "sitting" and "clap hand" items appear in two tools. So in total, there are three equate groups.

## Concurrent calibration {#sec:concurrent}

Patterns as in Figure \@ref(fig:equateex) occur if we have multiple forms of the same instrument. Although in theory there might be sequence effects, the usual working assumption is that we may ignore them. Equate groups with truly shared items that work in the same way across samples are of high quality. We may collect the responses on identical items into the same column of the data matrix. As a consequence, usual estimation methods will automatically produce one difficulty estimate for that column.

The procedure described above is known as *concurrent calibration*. See @kim1998 for background. The method simultaneously estimates the item parameters for all instruments. Concurrent calibration is an attractive option for various reasons:

* It yields a common latent scale across all instruments;
* It is efficient because it calibrates all items in a single run;
* It produces more stable estimates for shared items for small samples.

However, concurrent calibration depends on a strict distinction between items that are indeed the same across instruments and items that differ. 

In practice, strict black-white distinctions may not be possible. Items that measure the same skill may have been adapted to suit the format of the instrument (e.g. number of response options, question formulation, and so on). Also, investigators may have altered the item to suit the local language and cultural context. Such changes may or may not affect the measurement properties. The challenge is to find out whether items measure the underlying construct in the same way.

In practice, we may need to perform concurrent calibration to multiple - perhaps slightly dissimilar - milestones. When confronted with similar - but not identical - items, our strategy is first to form provisional equate groups. We then explore, test and rearrange these equate groups, in the hope of finding enough high-quality equate groups that will bridge instruments.


## Strategy to form and test equate groups {#sec:equaterules}

An equate group is a collection of items. As a part of concurrent calibration, we may specify that some equate groups are *active*. The analysis will treat items within such groups as one. The milestones within an active equate group will have the same difficulty estimate. Any remaining equate groups are called *passive* â€” the model views milestones within such groups as distinct. The milestones within a passive equate group will have separate difficulty estimates.

Active equate groups bridge different instruments. In general, we will set the status of an equate group to active only if we believe that the milestones in that group measure the underlying construct in the same way. Note that this does not necessarily imply that all items need to be identical. In Table \@ref(tab:example2words), for example, small differences exist in item formulation. We may nevertheless believe that these are irrelevant and ignore these in practice. Reversely, there is no guarantee that the same milestone will measure child development in the same way in different samples. For example, a milestone like "climb stairs" could be more difficult (and more dangerous) for children who have never seen a staircase.

Decisions to activate equate groups should be informed by both subject matter expertise and by the fit to the measurement model. The following steps implement our strategy for forming and enabling equate groups:

* Content matter experts compare milestones from different instruments and sort similar milestones into equate groups. It may be convenient to select one instrument as a starting point, and map items from others to that (see section \@ref(sec:mapping));
* Visualize age profiles of mapped items (see section \@ref(sec:viewmapping)). Verify the plausibility of potential matches through similar age profiles. Break up mappings for which age profiles appear implausible. This step requires both statistical and subject matter expertise;
* Fit the model to the data using a subset of equate groups as active. Review the quality of the solution and optimize the quality of the links between tools by editing the equate group structure. The technical details of this model are explained in section \@ref(sec:statisticalframe). Refit the model until (1) active equate groups link all cohorts and instruments, (2) active equate groups  distribute over the full-scale range (rather than being centered at one point);
* Assess the quality of equate groups by the infit and outfit (see section \@ref(sec:equatefit)).
* Test performance of the equate groups across subgroups or cohorts by methods designed to detect differential item functioning (see section \@ref(sec:equatedif)).

The application of equate groups is needed to connect different instruments to a universal scale. The technique is especially helpful in the situation where abilities differ across cohorts.

If the cohort abilities are relatively uniform (for example as a result of experimental design) and if the risk of misspecification of the equate groups is high, a good alternative is to rely on the equality of ability distribution. In our application, this was not an option due to the substantial age variation between cohorts.

## Parameter estimation with equate groups {#sec:statisticalframe}

The Rasch model is the preferred measurement model for child development data. [Booklet I: Chapter 4](https://stefvanbuuren.name/dbook1/ch-newmodel.html) provides an introduction of the Rasch model geared towards the $D$-score. 

The Rasch model expresses the probability of passing an item as a logistic function of the difference between the person ability $\beta_n$ and the item difficulty $\delta_i$. Table \@ref(tab:symbols) explains the symbols used in equation \@ref(eq:rasch). Formula \@ref(eq:rasch) defines the model as

\begin{equation}
\pi_{ni} = \frac{\exp(\beta_n - \delta_i)}{1+\exp(\beta_n -\delta_i)} (\#eq:rasch)
\end{equation}

One way to interpret the formula is as follows. The logarithm of the odds that a person with ability $\beta_n$ passes an item of difficulty $\delta_i$ is equal to the difference $\beta_n-\delta_i$ [@wright1982]. See the [booklet I: 4.6.1 logistic model](https://stefvanbuuren.name/dbook1/sec-itemresponsefunctions.html#logistic-model) for more detail.

In model \@ref(eq:rasch) every milestone $i$ has one parameter $\delta_i$. We extend the Rasch model by restricting the $\delta_i$ of all items within the same equate group to the same value. We thereby effectively say that these items are interchangeable measures of child development.

Estimation of the parameter for the equate group is straightforward. @wright1982 present a simple method for aligning two test forms with common items. There are three steps: 

* Estimate the separate $\delta_i$'s per item;
* Combine these estimates into $\delta_q$ by calculating their weighted average;
* Overwrite each $\delta_i$ by $\delta_q$.

Suppose that $Q$ is the collection of items in equate group $q$, and that $w_i$ is the number of respondents for item $i$. The parameter estimate $\delta_q$ for the equate group is

\begin{equation}
\delta_q = \frac{\sum_{i\in Q} \delta_iw_i}{\sum_{i\in Q} w_i}. (\#eq:raschequate)
\end{equation}


Symbol | Term  | Description
------------- | ------------- | -----------
$\beta_n$     | Ability       | True (but unknown) developmental score of child $n$
$\delta_i$    | Difficulty    | True (but unknown) difficulty of item $i$
$\delta_q$    | Difficulty    | The combined difficulty of the items in equate group $q$
$\pi_{ni}$    | Probability   | Probability that child $n$ passes item $i$
$l$           |               | The number of items in the equate group
$w_i$         |               | The number of respondents with an observed score on item $i$

: (\#tab:symbols) Overview the symbols used in equations \@ref(eq:rasch) and \@ref(eq:raschequate).

## Common latent scale {#sec:commonscale}

The end goal for using the equate group method to model development items is to measure development on one common latent scale, the $D$-score. That way, the measure (i.e. $D$-score) can be obtained, irrespective of which instrument is used in which population.

In Figure \@ref(fig:commonscale) the $D$-scores are displayed for three cohorts from the GCDG study: Netherlands 1 (GCDG-NLS-SMOCC), Ethiopia (GCDG-ETH) and Colombia 2 (GCDG-COL-LT42M). As described in section \@ref(sec:cohorts), the Netherlands 1 study contains the ddi; Ethiopia the by3; and Colombia the by3, den, asq and bdi. Accordingly there is some natural overlap in items between Ethiopia and Colombia via the by3 items. However, the Netherlands 1 cohorts is not linked via the items. In the upper plot, no equate groups were used and in the lower plot, equate groups link the cohorts.

```{r commonscale, echo=FALSE, fig.width = 8, fig.height = 4, fig.cap='(ref:commonscale)', cache = TRUE}

## model without equate groups
varlist_o <- dmetric::prepare_items(study = c("Netherlands 1", "Ethiopia", "Columbia 2"))
sub_items <- dscore::rename_gcdg_gsed(varlist_o$items)
varlist <- list(adm = c("subjid", "agedays", "cohort", "cohortn", "subjido"),
                items = sub_items)
sub_lean <- gseddata::get_data(cohorts = c(43,50,53), items = varlist$items, adm = varlist$adm)
model2 <-  fit_dmodel(varlist, data = sub_lean, equate = NULL,
                      name = "no_equates", age_unit = "years")

df1 <- model2$dscore %>% mutate(agemos = a*12)

p1 <- ggplot(data = df1) +  
  geom_point(aes(agemos, d, group=cohort, color=cohort), shape = 21, size = 0.7) +
  scale_colour_manual(values = dmetric::get_palette("study", "gsed"), na.value = "grey")+
  xlab("Age (months)")+
  ylab("D-score") +  
  theme(legend.position =  c(0.8,0.2), legend.title = element_blank())

#model with equate groups
model <- dmetric::model_lean
studies <- c("GCDG-ETH", "GCDG-NLD-SMOCC", "GCDG-COL-LT42M")
df2 <- model$dscore[which(model$dscore$cohort %in% studies),] %>% mutate(agemos = a *12)

p2 <- ggplot(data = df2)+
  geom_point( aes(agemos, d, group=cohort, color=cohort), shape = 21, size = 0.7)+
  scale_colour_manual(values = get_palette("study"), na.value = "grey")+ 
  xlab("Age(months)")+
  ylab("D-score") +  
  theme(legend.position =  c(0.8,0.2), legend.title = element_blank())

grid.arrange(p1, p2, ncol = 2)
```
(ref:commonscale) Example of three cohorts with and without equate group linking.

The plot for the model without equate groups shows that the scales for the Ethiopia and Colombia 2 studies are linked naturally via the shared items from by3. The Netherlands 1 cohort is not connected and follows a different track. In the plot for the model with equate groups, the scales for all three cohorts are connected. This example shows that equate groups can bring the abilities for children in different cohorts measured with different instrument onto one scale.


## Quantifying equate fit {#sec:equatefit}

In the Rasch philosophy it is the task of the data to fit the Rasch model. In order to verify the fit of the data to the model, we can assess the item fit and the person fit. Both fit measures are explained thoroughly in [Chapter 6 of booklet I](https://stefvanbuuren.name/dbook1/ch-evaluation.html). When we use equate groups in the Rasch model, we can also use these fit indices to determine the fit of the items in the equate groups.


### Well fitting equate groups

```{r plot_p_d_equate, include=FALSE}
plot_p_d_equate_i <- function(data,
                            model,
                            equates = NULL,
                            passive = FALSE,
                            metric = "dscore",
                            show_rug = TRUE,
                            show_curve = TRUE,
                            show_fit = TRUE,
                            file = NULL,
                            device = "pdf",
                            ...) {
  lean <- gseddata::is.lean(data)
  model_name <- model$name
  names(model$itembank)[names(model$itembank) == "lex_gsed"] <- "item"

  if (!"agedays" %in% names(data)) {
    data$agedays <- as.integer(data$age / 12 * 365.25)
  }

  # if no equates argument is specified, get equates from the
  # model, find equate groups with at least 2 items in the model
  if (is.null(equates))
    equatelist <- dmetric::get_equates(model)

  # if list of equate groups (name with item)
  if (is.list(equates) & length(equates) > 0) equatelist <- equates

  # if names in character vector, get equates subset from model
  if (!is.list(equates) & !is.null(equates))
    equatelist <- dmetric::get_equates(model)[equates]

  items_eq <- unique(unlist(equatelist))
  items <- intersect(model$items, items_eq)

  # no items left, return
  if (is.null(items)) return()

  # merge data to obtain d
  if (metric == "dscore") {
    modelb <- model$dscore
    colnames(modelb)[colnames(modelb) == "d"] <- "b"
    delta <- dscore::get_tau(model$items, "", model$itembank)
    beta_breaks <- seq(0, 80, 2)
    xlim <- c(0, 80)
    scale <- model$transform[2]
  }

  if (metric == "logit") {
    modelb <- model$beta_l
    delta <- model$fit$item[, "b"]
    names(delta) <- rownames(model$fit$item)
    delta <- delta[items]
    beta_breaks <-
      calculate_logit(seq(0, 80, 2), transform = model$transform)
    xlim <- c(-15, 25)
    scale <- 1
  }

  # merge data to obtain b
  if (!"agedays" %in% names(modelb))
    modelb$agedays <- as.integer(modelb$age * 365.25)
  if (!"study" %in% names(modelb))
    modelb$study <- modelb$cohort
  if (!"id" %in% names(modelb))
    modelb$id <- as.numeric(modelb$subjido)
  modelb <- modelb %>%
    select("study", "id", "agedays", "b")

  if (!lean) {
    if (!"study" %in% names(data))
      data$study <- data$cohort
    if (!"id" %in% names(data))
      data$id <- as.numeric(data$subjido)
    data <- data %>%
      select(one_of(c("study", "id", "agedays", items))) %>%
      pivot_longer(names_to = "item", values_to = "value", cols = -one_of(c("study", "id", "agedays"))) %>%
      drop_na("value", "study", "id", "agedays") %>%
      left_join(modelb, by = c("study", "id", "agedays"))
  }
  if (lean) {
    data <- data$itm %>%
      filter(item %in% items) %>%
      left_join(data$visit, by = c("subjid", "agedays"))%>%
      mutate(id = as.numeric(.data$subjido)) %>%
      left_join(modelb, by = c("id", "agedays"))
  }

  if (!"study" %in% names(data) & !"cohort" %in% names(data))
    data$study <- NA
  if (!"study" %in% names(data) & "cohort" %in% names(data))
    data$study <- data$cohort

  # proportion pass per dscore group
  # observations per months (n) by study and item
  pass <- data %>% filter(item %in% items) %>%
    drop_na("value", "b") %>%
    mutate(dgp = cut(.data$b, breaks = beta_breaks),
           age = .data$agedays / 365.25) %>%
    group_by(study, item, dgp) %>%
    summarise(
      p = round(100 * mean(.data$value, na.rm = TRUE)),
      a = mean(.data$age, na.rm = TRUE),
      b = mean(.data$b, na.rm = TRUE),
      n = n()) %>%
    ungroup() %>%
    left_join(model$itemtable, by = "item") %>%
    arrange(.data$equate, desc(.data$item))

  # define data for rug plot
  data_rug <- NULL
  if (show_rug)
    data_rug <- data %>%
    mutate(age = .data$agedays / 365.25) %>%
    select(one_of(c("study", "item", "age", "value", "b"))) %>%
    group_by(.data$study, .data$item, .data$age, .data$value) %>%
    summarise(b = mean(.data$b, na.rm = TRUE)) %>%
    ungroup() %>%
    left_join(model$itemtable, by = "item")%>% ##added to have instrument variable in rug data
    drop_na("b")

  plots <-
    plot_by_grp_i(
      pass,
      data_rug = data_rug,
      model_name = model_name,
      type = "d",
      metric = metric,
      xlim = xlim,
      package = model$data_package, ...)

  # add logistic curves
  if (show_curve) {
    idx <- match(names(plots), model$itembank$equate)
    location <- model$itembank$tau[idx]
    plots <- dmetric::show_logistic_curve(plots,
                                 location = location,
                                 scale = scale)
  }
  # add equate fit
  if (show_fit)
    plots <- show_equate_fit(plots, model$equate_fit, xlim = xlim)

  # add label signalling ACTIVE equate
  #plots <- show_active_equate(plots, active = model$active_equates)

  # save
  if (!is.null(file) & device == "pdf") {
    pdf(file,
        onefile = TRUE,
        width = 10,
        height = 5)
    lapply(plots, print)
    message("Saved to: ", file)
    dev.off()
  }

  if (!is.null(file) & device == "png") {
    paths <- paste0(file, names(plots), ".png")
    purrr::pwalk(list(filename = paths, plot = plots), ggsave)
  }

  invisible(plots)
}

plot_by_grp_i <- function(pass,
                        by_name = "equate",
                        model_name = "unspecified",
                        quiet = FALSE,
                        type = "d",
                        metric = "dscore", ...) {
  # sort equate groups
  by_grp <- unique(pass$equate)

  # remove missing groups
  if (any(is.na(by_grp))) by_grp <- by_grp[-which(is.na(by_grp))]

  # pre-allocate list of ggplots
  plot_list <- vector("list", length(by_grp))
  names(plot_list) <- by_grp

  # loop over plots
  for (i in seq_along(plot_list)) {
    if (!quiet) cat("Group: ", as.character(i), by_grp[i], "\n")
    if (type == "d") plot_list[[i]] <-
        plot_d_one_grp_i(pass,
                       by_name = by_name, by_value = by_grp[i],
                       i = i, model_name = model_name,
                       metric = metric, ...)
    else plot_list[[i]] <-
        plot_a_one_grp(pass,
                       by_name = by_name, by_value = by_grp[i],
                       i = i, model_name = model_name,
                       metric = metric, ...)
  }

  return(plot_list)
}

plot_d_one_grp_i <- function(pass,
                           data_rug = NULL,
                           by_name,
                           by_value,
                           i = 0,
                           min_n = 10,
                           model_name = "unspecified",
                           metric = "dscore",
                           xlim = c(0,80),
                           package = "gseddata",
                           ...) {
  if (by_name == "item")
    data_plot <- pass %>%
      filter(.data$item == by_value & .data$n >= min_n)

  if (by_name == "equate")
    data_plot <- pass %>%
      filter(.data$equate == by_value & .data$n >= min_n)

  items <- unique(data_plot$item)

  if (!is.null(data_rug) ){
  data_rug <- data_rug %>%
    filter(.data$item %in% items)
  }

  labels <- data_plot$label[match(items, data_plot$item)]
  labels <- substr(labels, 1L, 60L)

  # add study
  if (!"study" %in% names(data_plot))
    data_plot$study <- data_plot$cohort
  if (!"study" %in% names(data_rug))
    data_rug$study <- data_rug$cohort


  if (model_name != "") model_name<- paste("-", model_name)

  plot <- ggplot(data_plot, aes(b, p, group = interaction(study, item),
                                colour = instrument)) + ##_i instrument instead of study
    scale_x_continuous(paste0("Ability (", metric,") ", model_name,""),
                       limits = xlim,
                       breaks = seq(xlim[1], xlim[2], diff(xlim) / 8)) +
    scale_y_continuous("% pass", breaks = seq(0, 100, 10),
                       limits = c(0, 100)) +
    scale_colour_manual(values = dmetric::get_palette("instrument", package = package),
                        na.value = "grey")

  # add rugs
  if (!is.null(data_rug)) {
    if (nrow(data_rug) >= 1)
      plot <- plot +
        geom_rug(aes_string(x = "b", y = "value",
                            group = "instrument", colour = "instrument"),##_i instrument instead of study
                 data = filter(data_rug, .data$value == 0),
                 position = "jitter", sides = "b", size = 0.2) +
        geom_rug(aes_string(x = "b", y = "value",
                            group = "instrument", colour = "instrument"),##_i instrument instead of study
                 data = filter(data_rug, .data$value == 1),
                 position = "jitter", sides = "t", size = 0.2)
  }

  # add proportions
  if (nrow(data_plot) >= 1)
    plot <- plot +
    geom_line() + geom_point()

  # annotations
  plot <- plot +
    theme(legend.position = c(0.99, 0.05), legend.justification = c(1, 0),
          legend.key.size = unit(3.0, "mm"),
          legend.spacing.y = unit(0.5, "mm"),
          legend.background = element_rect(fill = "transparent", colour = "transparent")) +
    guides(fill = guide_legend(title = NULL)) +
    guides(col = guide_legend(ncol = 1)) +
    annotate("text", x = (xlim[1] + 1), y = 2, hjust = 0,
             label = as.character(i)) +
    annotate("text", x = (xlim[1] + 7), y = 2, hjust = 0,
             label = by_value)

  # item nams
  if (length(labels) > 0) {
    for (l in length(labels):1) {
      plot <- plot + annotate("text", x = (xlim[1] + 1), y = 7 + (l - 1) * 5, hjust = 0,
                              label = items[l], family = "Courier", fontface = "bold")
      if (!is.na(labels[l]))
        xfac <- 14
      if (metric == "logit") xfac <- 8
      plot <- plot + annotate("text", x = (xlim[1] + xfac), y = 7 + (l - 1) * 5, hjust = 0,
                              label = labels[l])
    }
  }
  return(plot)
}

show_equate_fit <- function(plot, equate_fit, xlim = c(0, 80)) {
  if (is.null(equate_fit))
    return(plot)
  if (is.ggplot(plot))
    return(annotate_item_fit(plot, itemfit = equate_fit))
  if (is.list(plot)) {
    for (i in seq_along(plot)) {
      the_name <- names(plot)[i]
      itemfit <- filter(equate_fit, equate == the_name)
      if (nrow(itemfit) == 1) plot[[i]] <-
        annotate_item_fit(plot[[i]], itemfit = itemfit, xlim = xlim)
    }
  }
  return(plot)
}

show_active_equate <- function(plot, active) {
  # active: vector of names of active equate groups
  # if (is.ggplot(plot)) return(annotate_active_equate(plot))
  #if (is.list(plot)) {
    for (i in seq_along(plot)) {
      the_name <- names(plot)[i]
      if (the_name %in% active)
        plot[[i]] <- annotate_active_equate(plot[[i]])
    }
  #}
  return(plot)
}

annotate_item_fit <- function(plot, itemfit, pole = TRUE, xlim=c(0,80)) {
  # function assumes that location is scalar and plot is ggplot
  if (!is.ggplot(plot)) stop("Argument plot not a ggplot.")
  if (is.na(itemfit[1])) return(plot)
  if (pole) {
    plot <- plot +
      annotate("text", x = (xlim[1]+1), y = 97, hjust = 0,
               label = paste0("Outfit ",
                              round(itemfit$outfit, 2),
                              "(",
                              round(itemfit$outfit_z, 2),
                              ")"))
    plot <- plot +
      annotate("text", x = (xlim[1]+1), y = 92, hjust = 0,
               label = paste0("Infit  ",
                              round(itemfit$infit, 2),
                              "(",
                              round(itemfit$infit_z, 2),
                              ")"))
  }
  else {
    plot <- plot +
      annotate("text", x = (xlim[1]+1), y = 82, hjust = 0,
               label = paste0("Outfit ",
                              round(itemfit$outfit, 2),
                              "(",
                              round(itemfit$outfit_z, 2),
                              ")"))
    plot <- plot +
      annotate("text", x = (xlim[1]+1), y = 77, hjust = 0,
               label = paste0("Infit  ",
                              round(itemfit$infit, 2),
                              "(",
                              round(itemfit$infit_z, 2),
                              ")"))
  }
  plot
}

```

The evaluation of *equate fit* involves comparing the observed probabilities of endorsing the items in the equate group to the estimated probability of endorsing the items in the equate group. In an equate group there is an empirical curve for each item in the equate group and one shared estimated curve. The empirical curves should all be close to the estimated curve for a good equate fit, as presented in the examples in Figure \@ref(fig:ploteqfit).

```{r ploteqfit, results = 'hide', fig.keep = 'all', fig.height = 10, fig.width=10, fig.cap = '(ref:ploteqfit)'}
ps <- plot_p_d_equate_i(data = dmetric::gcdg_lean , model = dmetric::model_lean)
gridExtra::grid.arrange(ps[["REC6"]], ps[["GM42"]])
```
(ref:ploteqfit) Two equate groups that present a good equate fit.

The equate *Turns head to sound of bell* is asked in slightly different formats in the Bayley I (`by1`), Dutch Development Instrument (`ddi`) and the Denver (`den`). The three items are combined in an equate group and the empirical data are colored differently for each instrument in the upper plot of Figure \@ref(fig:ploteqfit). Equate *Walks alone* is administered in six different instruments (`bar`, `by1`, `by2`, `by3`, `ddi` and `gri`) and is shown in the lower plot. For both equate groups, the empirical data for each instrument is close to the fitted dashed line, which indicates a good equate fit. The infit and outfit indices, shown in the upper left corners, confirm the good fit (fit < 1).

### Equate groups with poor equate fit

In modeling with equate groups, selecting the perfect combination of equate groups is a crucial step. Poor fitting equate groups need to be set as passive equate groups, such that the items in the group are not restricted to the same difficulty anymore. In a poor fitting equate group, the empirical curves for each item in the equate group are not close to the shared estimated curve. Additionally, the fit indices show poor fit as well (fit > 1). Two examples of poor equate fit are shown in Figure \@ref(fig:ploteqpoor).

```{r ploteqpoor, results = 'hide', fig.keep = 'all', fig.height = 10, fig.width=10, fig.cap = '(ref:ploteqpoor)',cache = TRUE}

varlist <- list(adm = c("subjid", "agedays", "cohort", "subjido"),
                items = gseddata::gcdg_items)
equatelist_poor <- gseddata::gcdg_equatelist
equatelist_poor$COG24 <- c("by1mdd066", "denfmd013")
#equatelist_poor$GM45 <- c("ddigmd070", "grigmd208")
#equatelist_poor$EXP23 <- c("barxxx014", "denlgd017", "grihsd213")
equatelist_poor$EXP12 <- c("by1mdd101", "ddicmm034", "grihsd011")
model_poor <- fit_dmodel(varlist, data = dmetric::gcdg_lean, equate = equatelist_poor,
                    name = "", age_unit = "years")

psp <- plot_p_d_equate_i(data = dmetric::gcdg_lean, equates = c("COG24", "EXP12"), model = model_poor)

gridExtra::grid.arrange(psp[["COG24"]], psp[["EXP12"]])
```
(ref:ploteqpoor) Two equate groups that present a poor equate fit.

The equate *Bangs in play / Bangs 2 blocks* is asked in two different instruments, the Bayley I (`by1`) and the Denver (`den`). The empirical curve for the `by1` item is not close to the fitted curve. The fitted curve is closer to the `den` item, which suggests that the equate difficulty is mostly based on the `den` item data. The fit indices are both larger than 1 also indicating the poor fit. The equate *Jabbers expressively* is asked in different forms in three instruments (i.e. `by1`, `ddi`, and `gri`). The empirical curves, with different colors for ech instrument, are not close to each other, nor close to the fitted curve. Also for this equate the fit indices confirm the poor fit (fit > 1). Both equates should be deactivated in an updated model.

## Differential item functioning {#sec:equatedif}

An important assumption for equate groups is that the items in the group work in the same way across the different cohorts, i.e., there is no differential item functioning. This means that the items in the equate group are equally difficult for children in different cohorts. This assumption is critical for active equate groups. If it is not met, restricting the difficulty parameters as equal across cohorts may introduce unwanted bias in comparisons between cohorts.

### Good equate group without DIF

In Figure \@ref(fig:plotnoeqdif), two active equate groups are displayed with empirical curves in different colors for each cohort. In both equate groups the curves are close to each other and to the fitted dashed curve. The lack of difference between the curves for the different cohorts, shows that there is no different equate functioning (i.e. different item functioning, DIF) between the cohorts.

```{r plotnoeqdif, results = 'hide', fig.keep = 'all', fig.height = 10, fig.width=10, fig.cap = '(ref:plotnoeqdif)'}
eqs <- c("FM31", "EXP26", "GM44", "EXP23")

eqs <- dmetric::get_equates(model = dmetric::model_lean, passive = TRUE)[eqs]

pdif <- dmetric::plot_p_d_equate(data =  dmetric::gcdg_lean, 
                                 model = dmetric::model_lean, 
                                 equates = eqs,
                                 passive = TRUE, show_fit = FALSE)
gridExtra::grid.arrange(pdif[["FM31"]], pdif[["EXP26"]])
```
(ref:plotnoeqdif) Two equate groups that present no differential item functioning between cohorts.


### Poor equate groups with DIF for study

In Figure \@ref(fig:ploteqdif), two passive equate groups are displayed, that show differential item functioning between cohorts. The empirical curves are displayed for each cohort separately in different colors. The difference between these curves shows the differential item functioning. For example, the item *Throws ball*, is easier for children in the South-Africa cohort (purple curve; GCDG-ZAF), and more difficult for children in Colombia (blue curve; GCDG-COL-LT42M). In other words, the probability to pass the item given the D-score (i.e. item difficulty) differs between the cohorts. The same goes for the item *Says more than 5 words*, which is easier for children in Jamaica (yellow and pink curves; GCDG-JAM-LBW and GCDG-JAM-SUNTED) and more difficult for children in Ecuador (green; GCDG-ECU).

```{r ploteqdif, results = 'hide', fig.keep = 'all', , fig.height = 10, fig.width=10, fig.cap = '(ref:ploteqdif)'}

gridExtra::grid.arrange(pdif[["GM44"]], pdif[["EXP23"]])

```
(ref:ploteqdif) Two equate groups that present differential item functioning between cohorts.

