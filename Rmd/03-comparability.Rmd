---
runtime: shiny 
---

<!-- NOTE: We may need to reorganise a little. Move "Challange of comparabiliy" and "Bridging instruments" to before chapter 2. Then this chapter can concentrate on the identification and assessment of similar items 
Jan2SvB: Now rewritten 3.1 to connectedness -->

# Comparability {#ch:comparability}

This chapter describes challenges and methodologies to harmonise child development measurements obtained by different instruments:

* Are instruments connected? (\@ref(sec:challenge))
* Bridging instruments by mapping items (\@ref(sec:mapping))
* Overview of promising item mappings (\@ref(sec:viewmapping))

## Are instruments connected? {#sec:challenge}

The ultimate goal is to compare child development across populations and cultures. A complication is that measurements are made by different instruments. To do deal with this issue, we harmonise the data included in the GCDG cohorts. In particular, we process the milestone responses such that the following requirements hold:

* Every milestone in an instrument has a unique name and a descriptive label;
* Every milestone occupies one column in the dataset;
* Item scores are (re)coded as: 1 = PASS; 0 = FAIL;
* Items not administered or not answered are a missing value;
* Every row in the dataset corresponds to a unique cohort-child-age combination.

Cohorts and milestones need to be *connected*. There are several ways to connect cohorts:

* Two cohorts are directly connected if they use the same instrument;
* Two cohorts are indirectly connected if both connect to a third cohort that connects them.

Likewise, instruments can be connected:

* Two instruments are directly connected if the same cohort measures both;
* Two instruments are indirectly connected if both connect to a third instrument that connects them.


```{r linkage, echo = FALSE}
pattern <- matrix("", nrow = 16, ncol = 15)
pattern[8, 1] <- "X"
pattern[9, 2] <- "X"
pattern[c(3, 5, 8), 3] <- "X"
pattern[4, 4] <- "X"
pattern[c(1, 16), 5] <- "X"
pattern[c(6, 7, 8, 10), 6] <- "X"
pattern[c(14, 15), 7] <- "X"
pattern[c(2, 8), 8] <- "X"
pattern[c(11, 12, 16), 9] <- "X"
pattern[13, 10] <- "X"
pattern[13, 11] <- "X"
pattern[13, 12] <- "X"
pattern[16, 13] <- "X"
pattern[5, 14] <- "X"
pattern[16, 15] <- "X"
colnames(pattern) <- 
  c("aqi", "bar", "bat", "by1", "by2", "by3", "ddi", 
    "den", "gri", "mac", "peg", "sbi", "sgr", "tep", "vin")
df <- data.frame(
  pattern,
  row.names = 
    c("Bangladesh", "Brazil 1", "Brazil 2", "Chile 1", "Chile 2", 
    "China", "Colombia 1", "Colombia 2", "Ecuador", "Ethiopia",
    "Jamaica 1", "Jamaica 2", "Madagascar", "Netherlds 1", 
    "Netherlds 2", "S Africa")

)

knitr::kable(df, 
  caption = "Linkage pattern indicating combinations of cohorts and instruments.",
  booktabs = TRUE) %>%
  kable_styling() %>%
  scroll_box(width = "100%", height = "500px")
```
&nbsp;

An "X" in table \@ref(tab:linkage) identifies which cohorts use which instruments. The linkage table shows that studies from China, Colombia and Ethiopia are directly connected (by `by3`). Brazil 1 indirectly connects to these groups through `den`. Other cohorts (e.g., Chile 1 and Ecuador) do not link to any other. Likewise, we might say that `aqi`, `bat`, `by3` and `den` are directly connected. Note that no indirect connections exist to this instrument group.

Table \@ref(tab:linkage) is a somewhat simplified version of the linkage pattern. In reality, there are substantial differences between the child ages of the cohorts. The table at <https://tnochildhealthstatistics.shinyapps.io/GCDG_instrument_linkage/> shows the actual counts per age group. What appears here as one test may actually be two disjoint subsets, and hence some cohorts may not be connected after all.

Connectedness is a necessary (though not sufficient) requirement for parameter identification. If two cohorts are not connected, we cannot distinguish between the following two alternative explanations:

* Any differences between studies can be attributed to the ability of the children;
* Any differences between studies can be attributed to the difficulties of the instruments.

The data do not contain the necessary information to discriminate between these two explanations. Since many cohorts in Table \@ref(tab:linkage) are unconnected, it seems that we are stuck. 

The next section suggests a way out of the dilemma.

## Bridging instruments by mapping items {#sec:mapping}

Items from different instruments can be mapped to each other by similarity. The by3 was the most frequently administered instrument in the cohorts, so the items from other instruments were mapped to the by3 items. Mapping was done based on similar wordings and descriptions in reference manuals by experienced subject matter experts. Additionally, same-skill items across other instruments were mapped into groups, if they did not map onto by3 items. Item mappings were ordered into five domains: fine motor (FM), gross motor (GM), cognitive (COG), receptive (REC) and expressive (EXP). Figure \@ref(fig:mapping) displays the connections between the instruments (blue nodes) via the item groups in each domain.

```{r mapping, echo=FALSE, fig.cap='(ref:mapping)', fig.height=7, fig.keep='all', warning=FALSE, results='hide'}
library(GGally)
library(network)
library(sna)
library(ggplot2)
library(dplyr)

varlist_gcdg <- dmetric::prepare_items(min_cat = 10)
eqset2 <- ddata::get_equates(varlist_gcdg$items)

eqinst <- eqset2 %>% lapply(dscore::rename_gcdg_gsed) 

#instrument vector:
instruments <- unique(dscore::get_itemtable(dscore::rename_gcdg_gsed(varlist_gcdg$items))$instrument)[-11]


mappings <- lapply(eqinst, function(x){
  y <- instruments %in% substr(x, 1, 3) * 1
  names(y) <- instruments
  y
})

mappings <- data.frame(mappings)

#mapp <- network(mappings, matrix.type = "bipartite")
#ggnet2(mapp, label = TRUE)
#mappings$COG <- rowSums(mappings[, colnames(mappings)[grepl("COG", colnames(mappings))] ])
#mappings$EXP <- rowSums(mappings[, colnames(mappings)[grepl("EXP", colnames(mappings))] ])
#mappings$REC <- rowSums(mappings[, colnames(mappings)[grepl("REC", colnames(mappings))] ])
#mappings$FM <- rowSums(mappings[, colnames(mappings)[grepl("FM", colnames(mappings))] ])
#mappings$GM <- rowSums(mappings[, colnames(mappings)[grepl("GM", colnames(mappings))] ])
#mapp2 <- network(mappings[,c("COG", "EXP", "REC", "GM", "FM")], matrix.type = "bipartite", ignore.eval = FALSE, names.eval = "weights")
#ggnet2(mapp2, label = TRUE)
#col = c("actor" = "grey", "event" = "gold")
#ggnet2(mapp2, color = "mode", palette = col, label = TRUE, edge.label = "weights")

col = c("actor" = "lightblue", "event" = "#FC8D62")
mapping_cog <- mappings[, colnames(mappings)[grepl("COG", colnames(mappings))]]
mapping_cog <- mapping_cog[which(rowSums(mapping_cog)>0),]
mapp_cog <-network(mapping_cog, 
                 matrix.type = "bipartite", ignore.eval = FALSE, names.eval = "weights")
cog_network<- ggnet2(mapp_cog, 
       label = instruments, 
       color = "mode", 
       alpha = "mode", 
       alpha.palette = c(1, 0.5), 
       palette = col, 
       #shape = "mode",
       #shape.palette = c(15,19), 
       legend.position = "none")+
  ggtitle("Cognitive equates")

col = c("actor" = "lightblue", "event" = "#A6D854")
mapping_exp <- mappings[, colnames(mappings)[grepl("EXP", colnames(mappings))]]
mapping_exp <- mapping_exp[which(rowSums(mapping_exp)>0),]
mapp_exp <-network(mapping_exp,
                 matrix.type = "bipartite", ignore.eval = FALSE, names.eval = "weights")
exp_network<- ggnet2(mapp_exp, 
       label = instruments, 
       color = "mode", 
       alpha = "mode", 
       alpha.palette = c(1, 0.5), 
       palette = col, 
       #shape = "mode",
       #shape.palette = c(15,19), 
       legend.position = "none")+
  ggtitle("Expressive equates")

col = c("actor" = "lightblue", "event" = "#8DA0CB")
mapping_fm <- mappings[, colnames(mappings)[grepl("FM", colnames(mappings))]]
mapping_fm <- mapping_fm[which(rowSums(mapping_fm)>0),]
mapp_fm <-network(mapping_fm,
                 matrix.type = "bipartite", ignore.eval = FALSE, names.eval = "weights")
fm_network<- ggnet2(mapp_fm, 
       label = instruments, 
       color = "mode", 
       alpha = "mode", 
       alpha.palette = c(1, 0.5), 
       palette = col, 
       #shape = "mode",
       #shape.palette = c(15,19), 
       legend.position = "none")+
  ggtitle("Fine motor equates")

col = c("actor" = "lightblue", "event" = "#E78AC3")
mapping_gm <- mappings[, colnames(mappings)[grepl("GM", colnames(mappings))]]
mapping_gm <- mapping_gm[which(rowSums(mapping_gm)>0),]
mapp_gm <-network(mapping_gm,
                 matrix.type = "bipartite", ignore.eval = FALSE, names.eval = "weights")
gm_network<- ggnet2(mapp_gm, 
       label = instruments, 
       color = "mode", 
       alpha = "mode", 
       alpha.palette = c(1, 0.5), 
       palette = col, 
       #shape = "mode",
       #shape.palette = c(15,19), 
       legend.position = "none")+
  ggtitle("Gross motor equates")

col = c("actor" = "lightblue", "event" = "#66C2A5")
mapping_rec <- mappings[, colnames(mappings)[grepl("REC", colnames(mappings))]]
mapping_rec <- mapping_rec[which(rowSums(mapping_rec)>0),]
mapp_rec <-network(mapping_rec,
                  matrix.type = "bipartite", ignore.eval = FALSE, names.eval = "weights")
rec_network<- ggnet2(mapp_rec, 
      label = instruments, 
       color = "mode", 
       alpha = "mode", 
       alpha.palette = c(1, 0.5), 
       palette = col, 
       #shape = "mode",
       #shape.palette = c(15,19), 
       legend.position = "none")+
  ggtitle("Receptive equates")

gridExtra::grid.arrange(cog_network, exp_network, gm_network, fm_network, rec_network)

```
(ref:mapping) Connections between the instruments via mapped item groups.

## Overview of promising item mappings {#sec:viewmapping}

```{r plot_p_a_eq, include=FALSE}
library("dmodel")
library("dmetric")
library("gseddata")

theme_set(theme_light())
model <- dmetric::model_lean
lean <- dmetric::gcdg_lean
eq_plots <- plot_p_a_equate(lean, model, passive = TRUE)

#plot_p_a_equate(lean, model, passive = TRUE, file = "C:/Users/eekhouti/Desktop/eq_a_dbook2.pdf")

```


<!-- NOTE: Suggesting "passing by age" as linking method may be confusing. If we do so, we should clearly explain that this is NOT the way we create equates, and explain the reasons why. -->

The potential of item mappings is evaluated visually by plotting the probability to pass items for age for the item groups and compare the curves between cohorts. When the data shows similar patterns between items and cohorts, the item mapping can be tested in the modelling phase. In Figure \@ref(fig:poteq), the probability to pass items for age is displayed for two potential bridges. 

The first plot presents a group of four cognitive items that assess the ability to put a cube or block in a cup or box. The items are administered in different studies and seem to work similarly. The second plot presents a group of six fine motor items that assess the ability to build a tower of six cubes or blocks. These items also seem to work similarly in the different cohorts.

```{r poteq, echo=FALSE, fig.height=7, fig.keep='all', warning=FALSE, results='hide', fig.cap = '(ref:poteq)'}

##promising equates
gridExtra::grid.arrange(
  eq_plots[["COG36"]],
  eq_plots[["FM38"]]
)

```
(ref:poteq) Probability to pass items for age in potential bridges.

When the patterns of the plotted data differ between items and/or cohorts, the mapping might not be a good one after all. This can be due to differences between populations or because the items work differently in different populations (i.e. differential item functioning). The exact cause of the missmatch can be further investigated in the modelling phase. In Figure \@ref(fig:badeq), two examples of poor item mappings are presented.

```{r badeq, echo=FALSE,  fig.height=7, fig.keep='all', warning=FALSE, results='hide', fig.cap = '(ref:badeq)'}

##bad equates
gridExtra::grid.arrange(
  eq_plots[["EXP12"]], ## ZA=GRI/BY1; NL=DDI; CL1=BY1
  eq_plots[["COG24"]] ## BR1=den; CO2=den; CL1=BY1; ZA=BY1
)
```
(ref:badeq) Probability to pass items for age in poor bridges.
