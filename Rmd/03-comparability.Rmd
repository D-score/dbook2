


<!-- NOTE: We may need to reorganise a little. Move "Challenge of comparability" and "Bridging instruments" to before chapter 2. Then this chapter can concentrate on the identification and assessment of similar items 
Jan2SvB: Now rewritten 3.1 to connectedness -->

# Comparability {#ch:comparability}

This chapter describes challenges and methodologies to harmonize child development measurements obtained by different instruments:

* Are instruments connected? (\@ref(sec:challenge))
* Bridging instruments by mapping items (\@ref(sec:mapping))
* Overview of promising item mappings (\@ref(sec:viewmapping))

## Are instruments connected? {#sec:challenge}

The ultimate goal is to compare child development across populations and cultures. A complication is that measurements are made by different instruments. To do deal with this issue, we harmonize the data included in the GCDG cohorts. In particular, we process the milestone responses such that the following requirements hold:

* Every milestone in an instrument has a unique name and a descriptive label;
* Every milestone occupies one column in the dataset;
* Item scores are (re)coded as: 1 = PASS; 0 = FAIL;
* Items not administered or not answered are a missing value;
* Every row in the dataset corresponds to a unique cohort-child-age combination.

Cohorts and milestones need to be *connected*. There are several ways to connect cohorts:

* Two cohorts are directly connected if they use the same instrument;
* Two cohorts are indirectly connected if both connect to a third cohort that connects them.

Likewise, instruments can be connected:

* Two instruments are directly connected if the same cohort measures both;
* Two instruments are indirectly connected if both connect to a third instrument that connects them.


```{r linkage, echo=FALSE}
suppressPackageStartupMessages(library(dplyr))

pattern <- matrix("", nrow = 16, ncol = 15)
pattern[8, 1] <- "X"
pattern[9, 2] <- "X"
pattern[c(3, 5, 8), 3] <- "X"
pattern[4, 4] <- "X"
pattern[c(1, 16), 5] <- "X"
pattern[c(6, 7, 8, 10), 6] <- "X"
pattern[c(14, 15), 7] <- "X"
pattern[c(2, 8), 8] <- "X"
pattern[c(11, 12, 16), 9] <- "X"
pattern[13, 10] <- "X"
pattern[13, 11] <- "X"
pattern[13, 12] <- "X"
pattern[16, 13] <- "X"
pattern[5, 14] <- "X"
pattern[16, 15] <- "X"
colnames(pattern) <- 
  c("aqi", "bar", "bat", "by1", "by2", "by3", "ddi", 
    "den", "gri", "mac", "peg", "sbi", "sgr", "tep", "vin")
df <- data.frame(
  pattern,
  row.names = 
    c("Bangladesh", "Brazil 1", "Brazil 2", "Chile 1", "Chile 2", 
    "China", "Colombia 1", "Colombia 2", "Ecuador", "Ethiopia",
    "Jamaica 1", "Jamaica 2", "Madagascar", "Netherlds 1", 
    "Netherlds 2", "S Africa")

)

knitr::kable(df, 
  caption = "Linkage pattern indicating combinations of cohorts and instruments.",
  booktabs = TRUE) %>%
  kableExtra::kable_styling() %>%
  kableExtra::scroll_box(width = "100%", height = "500px")
```
&nbsp;

An `X` in Table \@ref(tab:linkage) identifies which cohorts use which instruments. The linkage table shows that studies from China, Colombia and Ethiopia are directly connected (by `by3`). Brazil 1 indirectly connects to these studies through `den`. Some cohorts (e.g., Chile 1 and Ecuador) do not link to any other study. Likewise, we might say that `aqi`, `bat`, `by3` and `den` are directly connected. Note that no indirect connections exist to this instrument group.

Table \@ref(tab:linkage) is a somewhat simplified version of the linkage pattern. As we saw in section \@ref(sec:cohorts), there are substantial age differences between the cohorts. The linked [instrument linkage table](https://tnochildhealthstatistics.shinyapps.io/GCDG_instrument_linkage/) shows the counts of the number of registered scores per age group. What appears in Table \@ref(tab:linkage) as one test may actually comprise of two disjoint subsets, and hence some cohorts may not be connected after all.

Connectedness is a necessary - though not sufficient - requirement for parameter identification. If two cohorts are not connected, we cannot distinguish between the following two alternative explanations:

* Any differences between studies can be attributed to the ability of the children;
* Any differences between studies can be attributed to the difficulties of the instruments.

The data do not contain the necessary information to discriminate between these two explanations. Since many cohorts in Table \@ref(tab:linkage) are unconnected, it seems that we are stuck. 

The next section suggests a way out of the dilemma.

## Bridging instruments by mapping items {#sec:mapping}

Many instruments for measuring child development have appeared since the works of @shirley1933 and @gesell1943. It is no surprise that their contents show substantial overlap. All tools assess events like starting to see, hear, smile, fetch, crawl, walk, speak and think. 

We will exploit the overlap to bridge different instruments. For example, Table \@ref(tab:example2words) displays the labels of milestones from six instruments. All items probe the ability of the child to formulate "sentences" of two words.

```{r example2words, echo = FALSE}
items <- c("by1mdd136", "by2mdd114", "ddicmm041", "denlgd019",
           "grihsd217", "vinxxc016")
labels <- dscore::get_labels(items)
df <- tibble::tibble(Item = items, Label = labels)
t <- knitr::kable(df, booktabs = TRUE, 
             caption = "Example of similar items from different instruments.")
kableExtra::column_spec(t, 1, monospace = TRUE)
```
&nbsp;


The idea is to check whether these milestones measure development in the same way. If this is found to be accurate, then we may formally restrict the difficulty levels of these milestones to be identical. This restriction provides a formal bridge between the instruments. We repeat the process for all groups of similar-looking items.

A first step in the bridging process is to group items from different instruments by similarity. As the `by3` is relatively long and is the most often used instrument, it provides a convenient starting point. Subject matter experts experienced in child development mapped items from other tools to `by3` items. These experts evaluated the similarity of wordings and descriptions in reference manuals. Also, they mapped same-skill items across other instruments into groups if these did not map onto `by3` items.

We order item mappings into five domains: fine motor (FM), gross motor (GM),
cognitive (COG), receptive (REC) and expressive (EXP). Figure
\@ref(fig:mappingshiny) displays the connections
between the instruments via the item groups in each domain. The items are
displayed as the leafs and are colored by instrument. The blue lines display the
links between the items (and instruments).

```{r mappingfm, echo=FALSE, warning=FALSE,include=FALSE, results='hide'}
#fig.cap='(ref:mappingfm)', fig.height=7, fig.keep='all',
suppressPackageStartupMessages(library(ggraph))
suppressPackageStartupMessages(library(igraph))
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(dplyr))

varlist_gcdg <- dmetric::prepare_items(min_cat = 10)
eqset2 <- ddata::get_equates(varlist_gcdg$items)
eqinst <- eqset2 %>% lapply(dscore::rename_gcdg_gsed) 
inst_colors <- dmetric::get_palette("instrument")
names(inst_colors)[1] <- "aqi"
#######################attempt to order nodes by instrument
#make function to make hierachical edge network with equate list as input >> does not work bc each domain requires specific settings for the node labels.......
#fine motor -----
indicator <- which(grepl("FM", names(eqinst)))
eqinst1 <- eqinst[indicator]

eqlist <- eqinst1
itnames <- unlist(eqlist)
inst_grps <- data.frame(from = substr(itnames, 1,3), to = itnames)
inst_grps <- inst_grps[order(inst_grps$from),]
inst_top <- data.frame(from = "origin", to = unique(inst_grps$from))
hierarchy <- rbind(inst_top, inst_grps)

eqsub <- vector()
for(i in names(eqlist)){
  eqdf1 <- data.frame(eq = i, item = eqlist[[i]])
  eqsub <- rbind(eqsub, eqdf1)
}

#eqsub <- eqsub[order(as.character(eqsub[,"to"])),]
#hierarchy <- rbind(eqtop, eqsub)
vertices <- data.frame(name = unique(c(as.character(hierarchy$from), as.character(hierarchy$to))) ) 
vertices$group  <-  hierarchy$from[ match(vertices$name, hierarchy$to) ]
vertices$eq <- eqsub[match(vertices$name, eqsub$item), "eq"]


#make df of connections
eqcon <- vector()
for(i in names(eqlist)){
  eqcon1 <- combn(eqlist[[i]], m=2) 
  eqcon1 <- data.frame(from = eqcon1[1,], to = eqcon1[2,])
  eqcon <- rbind(eqcon, eqcon1)
}


#Let's add information concerning the label we are going to add: angle, horizontal adjustement and potential flip
#calculate the ANGLE of the labels
vertices$id  <- NA
myleaves <- which(is.na(match(vertices$name, hierarchy$from) ))
nleaves <- length(myleaves)
vertices$id[ myleaves ] <- seq(1:nleaves)
#vertices$angle <- 90 - 360 * vertices$id / nleaves 
vertices$angle <- 180 - 360 * vertices$id / nleaves ##!!! dit aangepast van voorbeeld! Werkt

# calculate the alignment of labels: right or left
# If I am on the left part of the plot, my labels have currently an angle < -90
vertices$hjust <- ifelse( vertices$angle < -90 | vertices$angle > 90, 1, 0)

# flip angle BY to make them readable
vertices$angle <- ifelse(vertices$angle < -90, vertices$angle+180, vertices$angle)
vertices$angle <- ifelse(vertices$angle > 90, vertices$angle - 180, vertices$angle)

# Create a graph object with the igraph library
mygraph <- graph_from_data_frame( hierarchy, vertices=vertices )
# This is a network object, you visualize it as a network like shown in the network section!
 
# The connection object must refer to the ids of the leaves:
from <- match(eqcon$from, vertices$name)
#from <- from[!is.na(from)]
to <- match(eqcon$to, vertices$name)
#to <- to[!is.na(to)] 


# With igraph: 
#plot(mygraph, vertex.label="", edge.arrow.size=0, vertex.size=2)
finemotormap <- 
ggraph(mygraph, layout = 'dendrogram', circular = TRUE) + 
   geom_node_point(aes(filter = leaf, x = x*1.05, y = y*1.05, colour = group), size = 3)+
  geom_conn_bundle(data = get_con(from= from, to = to), colour = "skyblue", alpha = 1, width = 0.9, tension = 0.9)+
geom_node_text(aes(x = x*1.1, y=y*1.1, filter = leaf, label=name, angle = angle, hjust=hjust, colour = group), size=3, alpha=1) +
  scale_colour_manual(values = inst_colors)+
  theme_void() +
  theme(
    legend.position="none",
    plot.margin=unit(c(0,0,0,0),"cm"),
  ) +
  expand_limits(x = c(-1.3, 1.3), y = c(-1.3, 1.3))+
  ggtitle("Fine Motor Domain")

#finemotormap
#(ref:mappingfm) Connections between the instruments via mapped item groups in the Fine motor domain.
```


```{r mappinggm, echo=FALSE, warning=FALSE,include=FALSE, results='hide'}
#fig.cap='(ref:mappinggm)', fig.height=7, fig.keep='all',
#gross motor-----
indicator <- which(grepl("GM", names(eqinst)))
eqinst1 <- eqinst[indicator]


eqlist <- eqinst1
itnames <- unlist(eqlist)
inst_grps <- data.frame(from = substr(itnames, 1,3), to = itnames)
inst_grps <- inst_grps[order(inst_grps$from),]
inst_top <- data.frame(from = "origin", to = unique(inst_grps$from))
hierarchy <- rbind(inst_top, inst_grps)

eqsub <- vector()
for(i in names(eqlist)){
  eqdf1 <- data.frame(eq = i, item = eqlist[[i]])
  eqsub <- rbind(eqsub, eqdf1)
}

#eqsub <- eqsub[order(as.character(eqsub[,"to"])),]
#hierarchy <- rbind(eqtop, eqsub)
vertices <- data.frame(name = unique(c(as.character(hierarchy$from), as.character(hierarchy$to))) ) 
vertices$group  <-  hierarchy$from[ match(vertices$name, hierarchy$to) ]
vertices$eq <- eqsub[match(vertices$name, eqsub$item), "eq"]


#make df of connections
eqcon <- vector()
for(i in names(eqlist)){
  eqcon1 <- combn(eqlist[[i]], m=2) 
  eqcon1 <- data.frame(from = eqcon1[1,], to = eqcon1[2,])
  eqcon <- rbind(eqcon, eqcon1)
}


#Let's add information concerning the label we are going to add: angle, horizontal adjustement and potential flip
#calculate the ANGLE of the labels
vertices$id  <- NA
myleaves <- which(is.na(match(vertices$name, hierarchy$from) ))
nleaves <- length(myleaves)
vertices$id[ myleaves ] <- seq(1:nleaves)
#vertices$angle <- 90 - 360 * vertices$id / nleaves 
vertices$angle <- 180 - 360 * vertices$id / nleaves ##!!! dit aangepast van voorbeeld! Werkt

# calculate the alignment of labels: right or left
# If I am on the left part of the plot, my labels have currently an angle < -90
  vertices$hjust <- ifelse( vertices$angle < -90 | vertices$angle > 90, 0, 1)
#vertices$hjust <- vertices$hjust +1
# flip angle BY to make them readable
vertices$angle <- ifelse(vertices$angle < -90, vertices$angle+180, vertices$angle)
vertices$angle <- ifelse(vertices$angle > 90, vertices$angle - 180, vertices$angle)

# Create a graph object with the igraph library
mygraph <- graph_from_data_frame( hierarchy, vertices=vertices )
# This is a network object, you visualize it as a network like shown in the network section!
 
# The connection object must refer to the ids of the leaves:
from <- match(eqcon$from, vertices$name)
#from <- from[!is.na(from)]
to <- match(eqcon$to, vertices$name)
#to <- to[!is.na(to)] 


# With igraph: 
#plot(mygraph, vertex.label="", edge.arrow.size=0, vertex.size=2)
grossmotormap <- 
ggraph(mygraph, layout = 'dendrogram', circular = TRUE) + 
   geom_node_point(aes(filter = leaf, x = x*1.05, y = y*1.05, colour = group), size = 3)+
  geom_conn_bundle(data = get_con(from= from, to = to), colour = "skyblue", alpha = 1, width = 0.9, tension = 0.9)+
geom_node_text(aes(x = x*1.1, y=y*1.1, filter = leaf, label=name, angle = angle, hjust=hjust, colour = group), size=3, alpha=1) +
  scale_colour_manual(values = inst_colors)+
  theme_void() +
  theme(
    legend.position="none",
    plot.margin=unit(c(0,0,0,0),"cm"),
  ) +
  expand_limits(x = c(-1.3, 1.3), y = c(-1.3, 1.3))+
  ggtitle("Gross Motor Domain")
#grossmotormap
#(ref:mappinggm) Connections between the instruments via mapped item groups in the Gross motor domain.
```


```{r mappingcog, echo=FALSE,  warning=FALSE,include=FALSE, results='hide'}
#fig.cap='(ref:mappingcog)', fig.height=7, fig.keep='all',

#cognitive ----
indicator <- which(grepl("COG", names(eqinst)))
eqinst1 <- eqinst[indicator]

eqlist <- eqinst1
itnames <- unlist(eqlist)
inst_grps <- data.frame(from = substr(itnames, 1,3), to = itnames)
inst_grps <- inst_grps[order(inst_grps$from),]
inst_top <- data.frame(from = "origin", to = unique(inst_grps$from))
hierarchy <- rbind(inst_top, inst_grps)

eqsub <- vector()
for(i in names(eqlist)){
  eqdf1 <- data.frame(eq = i, item = eqlist[[i]])
  eqsub <- rbind(eqsub, eqdf1)
}

#eqsub <- eqsub[order(as.character(eqsub[,"to"])),]
#hierarchy <- rbind(eqtop, eqsub)
vertices <- data.frame(name = unique(c(as.character(hierarchy$from), as.character(hierarchy$to))) ) 
vertices$group  <-  hierarchy$from[ match(vertices$name, hierarchy$to) ]
vertices$eq <- eqsub[match(vertices$name, eqsub$item), "eq"]


#make df of connections
eqcon <- vector()
for(i in names(eqlist)){
  eqcon1 <- combn(eqlist[[i]], m=2) 
  eqcon1 <- data.frame(from = eqcon1[1,], to = eqcon1[2,])
  eqcon <- rbind(eqcon, eqcon1)
}


#Let's add information concerning the label we are going to add: angle, horizontal adjustement and potential flip
#calculate the ANGLE of the labels
vertices$id  <- NA
myleaves <- which(is.na(match(vertices$name, hierarchy$from) ))
nleaves <- length(myleaves)
vertices$id[ myleaves ] <- seq(1:nleaves)
#vertices$angle <- 90 - 360 * vertices$id / nleaves 
vertices$angle <- 180 - 360 * vertices$id / nleaves ##!!! dit aangepast van voorbeeld! Werkt

# calculate the alignment of labels: right or left
# If I am on the left part of the plot, my labels have currently an angle < -90
vertices$hjust <- ifelse( vertices$angle < -90 | vertices$angle > 90, 1, 0)

# flip angle BY to make them readable
vertices$angle <- ifelse(vertices$angle < -90, vertices$angle+180, vertices$angle)
vertices$angle <- ifelse(vertices$angle > 90, vertices$angle - 180, vertices$angle)

# Create a graph object with the igraph library
mygraph <- graph_from_data_frame( hierarchy, vertices=vertices )
# This is a network object, you visualize it as a network like shown in the network section!
 
# The connection object must refer to the ids of the leaves:
from <- match(eqcon$from, vertices$name)
#from <- from[!is.na(from)]
to <- match(eqcon$to, vertices$name)
#to <- to[!is.na(to)] 


# With igraph: 
#plot(mygraph, vertex.label="", edge.arrow.size=0, vertex.size=2)
cognitivemap <- 
ggraph(mygraph, layout = 'dendrogram', circular = TRUE) + 
   geom_node_point(aes(filter = leaf, x = x*1.05, y = y*1.05, colour = group), size = 3)+
  geom_conn_bundle(data = get_con(from= from, to = to), colour = "skyblue", alpha = 1, width = 0.9, tension = 0.9)+
geom_node_text(aes(x = x*1.1, y=y*1.1, filter = leaf, label=name, angle = angle, hjust=hjust, colour = group), size=3, alpha=1) +
  scale_colour_manual(values = inst_colors)+
  theme_void() +
  theme(
    legend.position="none",
    plot.margin=unit(c(0,0,0,0),"cm"),
  ) +
  expand_limits(x = c(-1.3, 1.3), y = c(-1.3, 1.3))+
  ggtitle("Cognitive Domain")

#cognitivemap
#(ref:mappingcog) Connections between the instruments via mapped item groups in the Cognitive domain.
```


```{r mappingexp, echo=FALSE, warning=FALSE,include=FALSE, results='hide'}

#, fig.cap='(ref:mappingexp)', fig.height=7, fig.keep='all'}


#exp -----
indicator <- which(grepl("EXP", names(eqinst)))
eqinst1 <- eqinst[indicator]


eqlist <- eqinst1
itnames <- unlist(eqlist)
inst_grps <- data.frame(from = substr(itnames, 1,3), to = itnames)
inst_grps <- inst_grps[order(inst_grps$from),]
inst_top <- data.frame(from = "origin", to = unique(inst_grps$from))
hierarchy <- rbind(inst_top, inst_grps)

eqsub <- vector()
for(i in names(eqlist)){
  eqdf1 <- data.frame(eq = i, item = eqlist[[i]])
  eqsub <- rbind(eqsub, eqdf1)
}

#eqsub <- eqsub[order(as.character(eqsub[,"to"])),]
#hierarchy <- rbind(eqtop, eqsub)
vertices <- data.frame(name = unique(c(as.character(hierarchy$from), as.character(hierarchy$to))) ) 
vertices$group  <-  hierarchy$from[ match(vertices$name, hierarchy$to) ]
vertices$eq <- eqsub[match(vertices$name, eqsub$item), "eq"]


#make df of connections
eqcon <- vector()
for(i in names(eqlist)){
  eqcon1 <- combn(eqlist[[i]], m=2) 
  eqcon1 <- data.frame(from = eqcon1[1,], to = eqcon1[2,])
  eqcon <- rbind(eqcon, eqcon1)
}


#Let's add information concerning the label we are going to add: angle, horizontal adjustement and potential flip
#calculate the ANGLE of the labels
vertices$id  <- NA
myleaves <- which(is.na(match(vertices$name, hierarchy$from) ))
nleaves <- length(myleaves)
vertices$id[ myleaves ] <- seq(1:nleaves)
vertices$angle <- 90 - 360 * vertices$id / nleaves 
#vertices$angle <- 180 - 360 * vertices$id / nleaves ##!!! dit aangepast van voorbeeld! Werkt

# calculate the alignment of labels: right or left
# If I am on the left part of the plot, my labels have currently an angle < -90
vertices$hjust <- ifelse( vertices$angle < -90, 0, 1)

# flip angle BY to make them readable
vertices$angle <- ifelse(vertices$angle < -90, vertices$angle+180, vertices$angle)
#vertices$angle <- ifelse(vertices$angle > 90, vertices$angle - 180, vertices$angle)

# Create a graph object with the igraph library
mygraph <- graph_from_data_frame( hierarchy, vertices=vertices )
# This is a network object, you visualize it as a network like shown in the network section!
 
# The connection object must refer to the ids of the leaves:
from <- match(eqcon$from, vertices$name)
#from <- from[!is.na(from)]
to <- match(eqcon$to, vertices$name)
#to <- to[!is.na(to)] 


# With igraph: 
#plot(mygraph, vertex.label="", edge.arrow.size=0, vertex.size=2)
expressivemap <-
ggraph(mygraph, layout = 'dendrogram', circular = TRUE) + 
   geom_node_point(aes(filter = leaf, x = x*1.05, y = y*1.05, colour = group), size = 3)+
  geom_conn_bundle(data = get_con(from= from, to = to), colour = "skyblue", alpha = 1, width = 0.9, tension = 0.9)+
geom_node_text(aes(x = x*1.1, y=y*1.1, filter = leaf, label=name, angle = angle, hjust=hjust, colour = group), size=3, alpha=1) +
  scale_colour_manual(values = inst_colors)+
  theme_void() +
  theme(
    legend.position="none",
    plot.margin=unit(c(0,0,0,0),"cm"),
  ) +
  expand_limits(x = c(-1.3, 1.3), y = c(-1.3, 1.3))+
  ggtitle("Expressive Domain")

#expressivemap
#(ref:mappingexp) Connections between the instruments via mapped item groups in the Expressive language domain.
```


```{r mappingrec, eval=FALSE, warning=FALSE, include=FALSE, results='hide'}
#fig.cap='(ref:mappingrec)', fig.height=7, fig.keep='all',
#rec -----
indicator <- which(grepl("REC", names(eqinst)))
eqinst1 <- eqinst[indicator]


eqlist <- eqinst1
itnames <- unlist(eqlist)
inst_grps <- data.frame(from = substr(itnames, 1,3), to = itnames)
inst_grps <- inst_grps[order(inst_grps$from),]
inst_top <- data.frame(from = "origin", to = unique(inst_grps$from))
hierarchy <- rbind(inst_top, inst_grps)

eqsub <- vector()
for(i in names(eqlist)){
  eqdf1 <- data.frame(eq = i, item = eqlist[[i]])
  eqsub <- rbind(eqsub, eqdf1)
}

#eqsub <- eqsub[order(as.character(eqsub[,"to"])),]
#hierarchy <- rbind(eqtop, eqsub)
vertices <- data.frame(name = unique(c(as.character(hierarchy$from), as.character(hierarchy$to))) ) 
vertices$group  <-  hierarchy$from[ match(vertices$name, hierarchy$to) ]
vertices$eq <- eqsub[match(vertices$name, eqsub$item), "eq"]


#make df of connections
eqcon <- vector()
for(i in names(eqlist)){
  eqcon1 <- combn(eqlist[[i]], m=2) 
  eqcon1 <- data.frame(from = eqcon1[1,], to = eqcon1[2,])
  eqcon <- rbind(eqcon, eqcon1)
}


#Let's add information concerning the label we are going to add: angle, horizontal adjustement and potential flip
#calculate the ANGLE of the labels
vertices$id  <- NA
myleaves <- which(is.na(match(vertices$name, hierarchy$from) ))
nleaves <- length(myleaves)
vertices$id[ myleaves ] <- seq(1:nleaves)
#vertices$angle <- 90 - 360 * vertices$id / nleaves 
vertices$angle <- 180 - 360 * vertices$id / nleaves ##!!! dit aangepast van voorbeeld! Werkt

# calculate the alignment of labels: right or left
# If I am on the left part of the plot, my labels have currently an angle < -90
vertices$hjust <- ifelse( vertices$angle < -90 | vertices$angle > 90, 1, 0)

# flip angle BY to make them readable
vertices$angle <- ifelse(vertices$angle < -90, vertices$angle+180, vertices$angle)
vertices$angle <- ifelse(vertices$angle > 90, vertices$angle - 180, vertices$angle)

# Create a graph object with the igraph library
mygraph <- graph_from_data_frame( hierarchy, vertices=vertices )
# This is a network object, you visualize it as a network like shown in the network section!
 
# The connection object must refer to the ids of the leaves:
from <- match(eqcon$from, vertices$name)
#from <- from[!is.na(from)]
to <- match(eqcon$to, vertices$name)
#to <- to[!is.na(to)] 


# With igraph: 
#plot(mygraph, vertex.label="", edge.arrow.size=0, vertex.size=2)
receptivemap <- 
ggraph(mygraph, layout = 'dendrogram', circular = TRUE) + 
   geom_node_point(aes(filter = leaf, x = x*1.05, y = y*1.05, colour = group), size = 3)+
  geom_conn_bundle(data = get_con(from= from, to = to), colour = "skyblue", alpha = 1, width = 0.9, tension = 0.9)+
geom_node_text(aes(x = x*1.1, y=y*1.1, filter = leaf, label=name, angle = angle, hjust=hjust, colour = group), size=3, alpha=1) +
  scale_colour_manual(values = inst_colors)+
  theme_void() +
  theme(
    legend.position="none",
    plot.margin=unit(c(0,0,0,0),"cm"),
  ) +
  expand_limits(x = c(-1.3, 1.3), y = c(-1.3, 1.3))+
  ggtitle("Receptive Domain")

#receptivemap
#(ref:mappingrec) Connections between the instruments via mapped item groups in the Receptive language domain.

```


```{r mappingshiny, eval=FALSE, fig.align="center", fig.cap='(ref:mappingshiny)', fig.keep='all', fig.width=12, include=FALSE}
library(ggplot2)
library(gtools)
library(shiny)
library(shinyWidgets)
library(shinydashboard)
maplist <- list(finemotormap, grossmotormap, cognitivemap, expressivemap, receptivemap)
titlelist <- list(
  "Fine motor domain",
  "Gross motor domain",
  "Cognitive domain", 
  "Expressive domain", 
  "Receptive domain"
  
)
  steps <- reactiveVal(1)

  observeEvent(input$run1, {
    old_count = steps()
    if(old_count < 5){
    steps(old_count + 1)}
    if(old_count == 5){
      steps(old_count <- 1)
    }
  })
  observeEvent(input$prev1, {
    old_count = steps()
    if(old_count > 1){
      steps(old_count - 1)}
    if(old_count == 1){
      steps(old_count <- 5)
    }
  })


##UI
 # fluidRow(box(width = 1100,
#               column(6, offset = 5,
#     renderUI(
#    HTML(print(titlelist[[steps()]])))
#   )))
   fluidRow(box(width = 1100,
        column(1, offset = 0, actionButton("prev1", "Prev")),
        column(1, offset = 4, actionButton("run1", "Next"))
   )) 
   
   fluidRow(box(width = 900, 
  box(
     renderPlot({
         maplist[[steps()]]
  })
    )
   ))
  
   



```



```{r mappinshiny, echo = FALSE, fig.align="center", fig.cap='(ref:mappingshiny)', fig.keep='all', fig.width=11}
knitr::include_app("https://tnochildhealthstatistics.shinyapps.io/GCDG_mapping/", 
  height = "600px")
```
(ref:mappingshiny) Connections between the instruments via mapped item groups in each domain.


## Age profile of item mappings {#sec:viewmapping}

```{r plot_p_a_eq, echo=FALSE, message=FALSE, warning=FALSE}
suppressPackageStartupMessages(library("dmodel"))
suppressPackageStartupMessages(library("dmetric"))
suppressPackageStartupMessages(library("gseddata"))

theme_set(theme_light())
model <- dmetric::model_lean
#model$package <- model$data_package #fix this in dscore::get_itemtable or in dmetric plot_p_a_equate (model$package == "ddata")
lean <- dmetric::gcdg_lean
eq_plots <- plot_p_a_equate(lean, model, equates = c("COG36", "FM38", "EXP12", "COG24"), passive = TRUE)


#plot_p_a_equate(lean, model, passive = TRUE, file = "C:/Users/eekhouti/Desktop/eq_a_dbook2.pdf")
```



One way to explore the similarity of milestones from different instruments is to plot the probability of passing by age. Figure \@ref(fig:poteq) shows two examples.The first graph presents the age curves of a group of four cognitive items that assess the ability to put a cube or block in a cup or box. The milestones are administered in different studies and seem to work similarly. The second plot shows a similar graph for items that assess the ability to build a tower of six cubes or blocks. Also here the milestones have similar age patterns.

```{r poteq, echo=FALSE, fig.height=10, fig.width=10, fig.keep='all', warning=FALSE, results='hide', fig.cap = '(ref:poteq)'}

##promising equates
gridExtra::grid.arrange(
  eq_plots[["COG36"]],
  eq_plots[["FM38"]]
)

```
(ref:poteq) The probability of passing by age in potential bridging items.


Figure \@ref(fig:badeq) presents two examples of weak item mappings. Notable timing differences exist for the "babbles" and "bangs" milestones, which suggests that we should not take these as bridges.

```{r badeq, echo=FALSE,  fig.height=10, fig.width=10, fig.keep='all', warning=FALSE, results='hide', fig.cap = '(ref:badeq)'}

##bad equates
gridExtra::grid.arrange(
  eq_plots[["EXP12"]], ## ZA=GRI/BY1; NL=DDI; CL1=BY1
  eq_plots[["COG24"]] ## BR1=den; CO2=den; CL1=BY1; ZA=BY1
)
```
(ref:badeq) Probability to pass items for age in poor bridges.

 

While these plots are suggestive, their interpretation is surprisingly complicated. We may find that age profiles of two milestones *A and B* administered in samples 1 and 2 respectively *are identical* if

* A and B are equally difficult and samples 1 and 2 have the same maturation level;
* A is more difficult than B and sample 1 is more advanced than 2.

Similarly, we may find that the age profile for *A is earlier than B* if

* A is easier than B and if samples 1 and 2 have the same level of maturation;
* A and B are equally difficult and if sample 1 is more advanced than sample 2.

Note that the age curves confound difficulty and ability, and hence cannot be used to evaluate the quality of the item map. 

What we need to do is separate difficulty and ability. For this, we need a formal statistical model. The next chapter introduces the concepts required in such a model.
