# Comparing ability {#ch:ability}

In this chapter the $D$-score distributions per GCDG cohort are displayed and
the impact of measurement error is compared between the cohorts. Additionally
the coverage of the developmental domains is displayed for $D$-score scale and
for a single $D$-score.

* D-score distribution by study (\@ref(sec:dscores))
* Impact of measurement error (\@ref(sec:sem))
* Domain coverage and scores (\@ref(sec:domains))

## D-score distribution by study {#sec:dscores}

For each study that is included in the GCDG assembly, the $D$-score can be
obtained using the developed global model. In the graphs below, the $D$-score
distributions are displayed for each cohort separately. The blue lines in the
graphs are the (temporary) references, as explained in \@ref(sec:references).
By using the `next` button below the plot you can click through the cohorts.
Using the selection bar above the graph, you can select a specific cohort.

```{r echo=FALSE, fig.width=11}
knitr::include_app("https://tnochildhealthstatistics.shinyapps.io/GCDG_dscores/", 
  height = "700px")
```
(ref:dscoredist) $D$-score distributions by study.

```{r eval=FALSE, message=FALSE, warning=FALSE, include=FALSE}

library(ggplot2)
library(dplyr)
library(dmetric)
library(gtools)
library(shiny)
library(shinyWidgets)
library(shinydashboard)

# d by study
coh_ls <-
  as.character(unlist(mixedsort(unique(
    dmetric::model_lean$dscore["cohort"]
  ))))
#show the sem by cohort
coh_ls <- coh_ls[!is.na(coh_ls)]

    count_coh <- reactiveVal(1)

    observeEvent(input$run1,{
        old_count = count_coh()
        count_coh(old_count + 1)
    })
    observeEvent(input$prev1,{
        old_count = count_coh()
        count_coh(old_count - 1)
    })

    observeEvent(input$cohort_list,{
        count_coh(which(coh_ls == input$cohort_list))
    })

    observe({
        if (length(count_coh()) > 0) {
            updateSelectInput(session,
                              "cohort_list",
                              choices = coh_ls,
                              selected = coh_ls[count_coh()])
        }
        if (length(count_coh()) == 0) {
            updateSelectInput(session,
                              "cohort_list",
                              choices = coh_ls,
                              selected = coh_ls[1])
        }
    })

    
    
        fluidRow(box(
                     column(width = 5, offset = 0,
                            selectInput(
                                inputId = "cohort_list",
                                label = "cohort list",
                                choices = ""
                            ))))

            fluidRow(
                          renderPlot({
   
    print(
      dmetric::plot_d_a_group(
        data = dmetric::gcdg_lean,
        model = dmetric::model_lean,
        by = "cohort",
        ref_name = "gcdg",
        grouping = coh_ls[which(coh_ls == input$cohort_list)],
        print_model_name = FALSE
      )
    )

        }) 
                                        
                                        )
        
            
            fluidRow(
                column(1, offset = 1, actionButton("prev1", "Prev")),
                column(1, offset = 5, actionButton("run1", "Next"))
            )
        
```



## Impact of measurement error {#sec:sem}

For each estimated $D$-score from the calibrated model, the precision of the
estimate can be determined. This precision can be expressed as the standard
error of measurement ($sem$). The standard error of measurement is inversely
related to the number of items. Thus, when more items are administered for a
person, the measurement error for the $D$-score of this person will be smaller.
As is shown in Figure \@ref(fig:semforn), the sem drops fast when the number of
items is increased to 15, and still some more until the number of items is 30.
More than 30 items has little effect on the sem.


```{r semforn, results = 'hide', fig.keep = 'all', warning = FALSE, fig.cap = '(ref:semforn)', message = FALSE, echo = FALSE}
library(ggplot2)

ggplot(data = dmetric::model_lean$dscore )+
  geom_smooth(aes(x=n, y=sem), se = FALSE, color = "red")+
  xlab("number of items")
```
(ref:semforn) Standard error of measurement when the number of items increases.


The precision of the $D$-score estimate is also affected by the information in
the items that are administered. This is partly the number of items, as depicted
in \@ref(fig:semforn), but also if the items are informative for the $D$-score.
For example, if the items are too easy and the probability to pass the item
given the $D$-score is $P$ > 0.90, the $sem$ is larger than when the difficulty
of the administered items is closer to the $D$-score (i.e. $P$ = 0.50). The
$sem$ for age in GCDG data (see Figure \@ref(fig:semfora)) shows that for some
ages, the $sem$ is larger than for others. This is on the one hand due to the
number of items available in that age range, but also to the design of the
cohorts where sometimes relatively easy items are administered.


```{r semfora, echo=FALSE, fig.cap='(ref:semfora)', fig.keep='all', message=FALSE, warning=FALSE, results='hide'}
library("dmetric")
library("gseddata")
library("dplyr")

# voor individuele metingen
sem_daz <- dmetric::model_lean$dscore %>%
  mutate(agemos = a *12,
         low_d = d - sem,
         high_d = d +sem, 
         low_daz = dscore::daz(low_d, x = a),
         high_daz = dscore::daz(high_d, x = a))


## of dit berekenen via de pooled sem per age group en daarna pas naar daz omzetten
#pooled sem = srqt(sum(sem^2)/(length(sem)-1))
#alleen gaat het dan mis dat de gemiddelde daz soms buiten het inderval komt (in begin maanden vooral)
#>># proberen door between variantie (var(d)) toe te voegen aan de pooling van de varianties
sem_daz_a <- sem_daz %>% 
  mutate(agecat = cut(agemos, breaks = 0:max(agemos, na.rm=TRUE)), 
         agenum = as.numeric(agecat))%>%
  group_by(agenum) %>% 
  summarize (daz = mean(daz, na.rm = TRUE),
             mean_a = mean(a, na.rm=TRUE), #voor omzetting naar daz
             mean_d = mean(d, na.rm = TRUE),
             var_betw = var(d, na.rm = TRUE),
             var_with = sum(sem^2, na.rm = TRUE),
             n =  sum(!is.na(sem))
             ) %>% ungroup() %>%
  mutate(sem_pool = sqrt((var_with + var_betw)/ (n-1)), 
         low_d = mean_d - sem_pool,
         high_d = mean_d + sem_pool,
         mean_daz = dscore::daz(mean_d, x = mean_a),
         low_daz = dscore::daz(low_d, x = mean_a),
         high_daz = dscore::daz(high_d, x = mean_a))

#ggplot(data = sem_daz_a )+
#  geom_point(aes(x=agenum, y=daz)) +
#  geom_errorbar(aes(x = agenum, ymin=low_daz, ymax=high_daz), width=.1)+
#  xlab("age(months)")+
#  ylim(c(-2,2))

ggplot(data = sem_daz_a )+
  geom_point(aes(x=agenum, y=mean_daz)) +
  geom_errorbar(aes(x = agenum, ymin=low_daz, ymax=high_daz), width=.1)+
  xlab("age(months)")+ ylab("daz")+
  ylim(c(-2,2))

#ggplot(data = sem_daz_a )+
#  geom_point(aes(x=agenum, y=mean_d)) +
#  geom_errorbar(aes(x = agenum, ymin=low_d, ymax=high_d), width=.1)+
#  xlab("age(months)") + ylab("D-score")


```
(ref:semfora) Standard error of measurement in each age group.

In Figure \@ref(fig:dscoresems), the $sem$ per age group is shown for each
cohort separately. This illustrates the differences in design between the
cohorts. For example, the Netherlands 1 cohort (GCDG-NLD-SMOCC), the `ddi` was
used as a screener and items had the probability to pass of approximately
$P$=0.80 (quartile range between 0.62 < $P$ > 1.00), and the number of items
administered per measurement is about 10 items (quartile range 6 to 12 items).
The Colombia 1 cohort (GCDG-COL-LT45M) was an impact evaluation and has
administered the `by3` where each child answered on average 45 items (quartile
range 38 to 57 items) and the probability to pass was approximately $P$ = 0.64
(quartile range between 0.53 < $P$ > 0.79). The latter study has therefore more
precise $D$-score estimates.

```{r dscoresems, echo=FALSE, fig.width=11, fig.cap = '(ref:dscoresems)'}
#n items per child Netherlands 1 cohort = 8.5
#ids <- gcdg_lean$visit$subjid[which(gcdg_lean$visit$cohort=="GCDG-NLD-SMOCC")]
#itm <- gcdg_lean$itm[which(gcdg_lean$itm$subjid %in% ids),]
#itmn <- itm %>% group_by(subjid, agedays) %>% summarize(n=n())
#summary(itmn)
#p per child on average for Netherlands 1 cohort = 0.8 (median)
#summary(model_lean$dscore$p[which(model_lean$dscore$cohort == "GCDG-NLD-SMOCC")])

#n items per child Colombia cohort = 46
#ids <- gcdg_lean$visit$subjid[which(gcdg_lean$visit$cohort=="GCDG-COL-LT45M")]
#itm <- gcdg_lean$itm[which(gcdg_lean$itm$subjid %in% ids),]
#itmn <- itm %>% group_by(subjid, agedays) %>% summarize(n=n())
#summary(itmn)
#p per child on average for Colombia 1 cohort = 0.63 (median)
#summary(model_lean$dscore$p[which(model_lean$dscore$cohort == "GCDG-COL-LT45M")])


knitr::include_app("https://tnochildhealthstatistics.shinyapps.io/GCDG_sem/", 
  height = "700px")
```
(ref:dscoresems) The standard error of measurement around the standardized $D$-scores (DAZ) per cohort


```{r eval=FALSE, message=FALSE, include=FALSE, warnings=FALSE, echo = FALSE}

library(ggplot2)
library(dplyr)
library(dmetric)
library(gtools)
library(shiny)
library(shinyWidgets)
library(shinydashboard)


model <- dmetric::model_lean
data_input <- dmetric::gcdg_lean

# d by study
coh_ls <-
  as.character(unlist(mixedsort(unique(
    dmetric::model_lean$dscore["cohort"]
  ))))
#show the sem by cohort
coh_ls <- coh_ls[!is.na(coh_ls)]

sem_daz <- dmetric::model_lean$dscore %>%
  mutate(agemos = a *12,
         low_d = d - sem,
         high_d = d +sem,
         low_daz = dscore::daz(low_d, x = a),
         high_daz = dscore::daz(high_d, x = a))

sem_daz_a <- sem_daz %>%
  mutate(agecat = cut(agemos, breaks = 0:max(agemos, na.rm=TRUE)),
         agenum = as.numeric(agecat))%>%
  group_by(agenum, cohort) %>%
  summarize (daz = mean(daz, na.rm = TRUE),
             mean_a = mean(a, na.rm=TRUE), #voor omzetting naar daz
             mean_d = mean(d, na.rm = TRUE),
             var_betw = var(d, na.rm = TRUE),
             var_with = sum(sem^2, na.rm = TRUE),
             n =  sum(!is.na(sem))
  ) %>% ungroup() %>%
  mutate(sem_pool = sqrt((var_with + var_betw)/ (n-1)),
         low_d = mean_d - sem_pool,
         high_d = mean_d + sem_pool,
         mean_daz = dscore::daz(mean_d, x = mean_a),
         low_daz = dscore::daz(low_d, x = mean_a),
         high_daz = dscore::daz(high_d, x = mean_a))


    count_coh <- reactiveVal(1)

    observeEvent(input$run1,{
        old_count = count_coh()
        count_coh(old_count + 1)
    })
    observeEvent(input$prev1,{
        old_count = count_coh()
        count_coh(old_count - 1)
    })

    observeEvent(input$cohort_list,{
        count_coh(which(coh_ls == input$cohort_list))
    })

    observe({
        if (length(count_coh()) > 0) {
            updateSelectInput(session,
                              "cohort_list",
                              choices = coh_ls,
                              selected = coh_ls[count_coh()])
        }
        if (length(count_coh()) == 0) {
            updateSelectInput(session,
                              "cohort_list",
                              choices = coh_ls,
                              selected = coh_ls[1])
        }
    })

    
    
        fluidRow(box(
                     column(width = 5, offset = 0,
                            selectInput(
                                inputId = "cohort_list",
                                label = "cohort list",
                                choices = ""
                            ))))

            fluidRow(
                          renderPlot({
        print(
            ggplot()+
                geom_point(data = subset(sem_daz,cohort == coh_ls[which(coh_ls == input$cohort_list)]),aes(x = agemos, y = daz), color = "lightgrey")+
                geom_errorbar(data = subset(sem_daz,cohort == coh_ls[which(coh_ls == input$cohort_list)]),aes(x = agemos, ymin = low_daz, ymax = high_daz), color = "lightgrey")+
            geom_point(data = subset(sem_daz_a,cohort == coh_ls[which(coh_ls == input$cohort_list)]), aes(x = agenum, y = mean_daz))+
            geom_errorbar(data = subset(sem_daz_a,cohort == coh_ls[which(coh_ls == input$cohort_list)]),aes(x = agenum, ymin = low_daz, ymax = high_daz))+
                xlab("age(month)")+ ylab("daz(sem)")+
                ylim(c(-2,2))+xlim(c(0,48))+
                ggtitle("All data points")

        )}) 
                                        
                                        )
        
            
            fluidRow(
                column(1, offset = 1, actionButton("prev1", "Prev")),
                column(1, offset = 5, actionButton("run1", "Next"))
            )
        

        

#ggplot(data = sem_daz_a )+
#  geom_point(aes(x=agenum, y=daz)) +
#  geom_errorbar(aes(x = agenum, ymin=low_daz, ymax=high_daz), width=.1)+
#  xlab("age(months)")+
#  ylim(c(-2,2))

#ggplot(data = sem_daz_a )+
#  geom_point(aes(x=agenum, y=mean_daz)) +
#  geom_errorbar(aes(x = agenum, ymin=low_daz, ymax=high_daz), width=.1)+
#  xlab("age(months)")+ ylab("daz")
#  ylim(c(-2,2))

#ggplot(data = sem_daz_a )+
#  geom_point(aes(x=agenum, y=mean_d)) +
#  geom_errorbar(aes(x = agenum, ymin=low_d, ymax=high_d), width=.1)+
#  xlab("age(months)") + ylab("D-score")


```


The $sem$ for an entire cohort or sample can be obtained by pooling the
individual $sem_i$ using general rule for pooling variances. Accordingly, the
$sem$ for a sample is obtained by combining the within variance
$\sum{sem_{i}^2}$ and the between variance $\sigma_d$ as in equation
\@ref(eq:poolsem)

\begin{equation}
sem = \sqrt{\frac{\sum{sem_{i}^2} + \sigma_d }{N-1}} (\#eq:poolsem)
\end{equation}

In Figure \@ref(fig:cohortsem) the sample $sem$ per cohort is displayed. The
lowest sample $sem$ is found in the Ethiopia study (GCDG-ETH) and the highest in
the South Africa cohort (GCDG-ZAF). This can be explained on the one hand by the
number of items per child, and on the other hand the difficulty of the
administered items. 

```{r cohortsem, results = 'hide', fig.keep = 'all', warning = FALSE, fig.cap = '(ref:cohortsem)', message = FALSE, echo = FALSE}
sem_daz_c <- sem_daz %>% 
  mutate(agecat = cut(agemos, breaks = 0:max(agemos, na.rm=TRUE)), 
         agenum = as.numeric(agecat))%>%
  group_by(cohort) %>% summarize ("n Q1(0.25)" = quantile(n, probs = 0.25, na.rm=TRUE), 
                                  "test length (median)" = median(n, na.rm = TRUE), 
                                  "n Q3(0.75)" = quantile(n, probs = 0.75, na.rm=TRUE), 
                                  "p Q1(0.25)" = round(quantile(p, probs = 0.25, na.rm=TRUE),2), 
                                  "pass probability (median)" = round(median(p, na.rm=TRUE),2),
                                  "p Q3(0.75)" = round(quantile(p, probs = 0.75, na.rm=TRUE),2),
                                  daz = mean(daz, na.rm = TRUE),
                                  mean_a = mean(a, na.rm=TRUE), #voor omzetting naar daz
                                  mean_d = mean(d, na.rm = TRUE),
                                  var_betw = var(d, na.rm = TRUE),
                                  var_with = sum(sem^2, na.rm = TRUE),
                                  n =  sum(!is.na(sem))
  ) %>% ungroup() %>%
  mutate(sem_pool = sqrt((var_with + var_betw)/ (n-1)), 
         low_d = mean_d - sem_pool,
         high_d = mean_d + sem_pool,
         mean_daz = dscore::daz(mean_d, x = mean_a),
         low_daz = dscore::daz(low_d, x = mean_a),
         high_daz = dscore::daz(high_d, x = mean_a)) %>%
  arrange(sem_pool)

  ggplot(data = sem_daz_c, aes(reorder(cohort, sem_pool), sem_pool)) +
  geom_col() + theme(axis.text.x = element_text(angle = 60, hjust = 1))+
    xlab("")+ ylab("cohort sem")
  
  ## attach main instrument to cohort and see if that relates to sem? Or study kind? Something like that?
 
```
(ref:cohortsem) Standard Error of Measurement per cohort.


Table \@ref(tab:npsem) shows the median
number of items per child (test length) and the probability to pass the items (p). In The
Ethiopia cohort 39 items were administered with a median
probability of 0.66 and in the South Africa study just 12 items with a median
probability of 1. Accordingly, in the Ethiopia study more items were
administered per child that also have a high level of information for the
$D$-scores. In the South Africa study only few items were administered per child
that were also relatively easy and therefore contained less information for the
$D$-scores.


```{r npsem, echo = FALSE}
library(kableExtra)
kable(sem_daz_c[,c(1,3,6)], 
      caption = "Test length and probability to pass the items per cohort",
      bootabs = TRUE)

```
&nbsp;

## Domain coverage and scores {#sec:domains}
 
The $D$-score is a one number score that measures early child development. To
evaluate the content validity of the $D$-score we can make sure that all
developmental domains are fairly represented. We distinguish five domains for
child development: Fine Motor, Gross Motor, Expressive, Receptive, Cognitive. 

### Domain coverage of the scale

The items in the $D$-score model can be linked to one or more domains and the
cumulative item information to the $D$-score for each domain can be evaluated.
In Figure \@ref(fig:domaincov), the coverage of the domains for the $D$-score is
displayed. This shows that at lower levels of the $D$-score, gross motor development
is more dominant and that at higher levels of the $D$-score the cognitive and
language domains increase in importance.


```{r domaincov, results = 'hide', fig.keep = 'all', warning = FALSE, fig.cap = '(ref:domaincov)', message = FALSE, echo = FALSE}
library(tidyr)
library(dplyr)


info_data <-
      dinstrument::info_d_item(
        itembank = model_lean$itembank,
        delta = "tau",
        alpha = NULL,
        long = TRUE,
        beta_range = 0:80
      )
 domaintable <- ddomain::get_domaintable("gcdg")
 info_wby_domain <- info_data %>% left_join(domaintable) %>%
        mutate(
          gm_info = .data$Gross.Motor * .data$info,
          fm_info = .data$Fine.Motor * .data$info,
          exp_info = .data$Expressive * .data$info,
          rec_info = .data$Receptive * .data$info,
          cog_info = .data$Cognitive * .data$info,
          adp_info = .data$Adaptive * .data$info) %>%
        group_by(ability) %>%
        summarise(
          "Gross Motor" = sum(.data$gm_info, na.rm = TRUE)/sum(.data$info, na.rm = TRUE) *100,
          "Fine Motor" = sum(.data$fm_info, na.rm = TRUE)/sum(.data$info, na.rm = TRUE) *100,
          "Expressive" = sum(.data$exp_info, na.rm = TRUE)/sum(.data$info, na.rm = TRUE) *100,
          "Receptive" = sum(.data$rec_info, na.rm = TRUE)/sum(.data$info, na.rm = TRUE) *100,
          "Cognitive" = sum(.data$cog_info, na.rm = TRUE)/sum(.data$info, na.rm = TRUE) *100,
          "Adaptive" = sum(.data$adp_info, na.rm=TRUE)/sum(.data$info, na.rm = TRUE) *100,
          missing = (sum(.data$info) - sum(.data$gm_info, na.rm = TRUE) -
                       sum(.data$fm_info, na.rm = TRUE) - sum(.data$cog_info, na.rm = TRUE) -
                       sum(.data$exp_info, na.rm = TRUE) - sum(.data$rec_info, na.rm = TRUE) - sum(.data$adp_info, na.rm=TRUE) ) /sum(.data$info, na.rm = TRUE) *100
        ) %>%
        gather(key = "domain",
               value = "info",
               "Gross Motor",
               "Fine Motor",
               "Receptive",
               "Expressive",
               "Cognitive",
               "Adaptive",
               missing) %>%
        mutate(domain = ifelse(.data$domain =="missing",  NA, .data$domain))

 
    ggplot(data = info_wby_domain, aes(x = ability, y = info, fill = domain)) +
      geom_bar(stat = "identity") +
      ylab("% of information") +
      xlab("Ability (D-score)")+
      scale_color_manual(values = dmodel::get_color_domain("gcdg"),
                         na.value = "grey")

  

```
(ref:domaincov) Domain coverage of the $D$-score scale.


### Domain $D$-scores

It is possible to calculate a $D$-score that is more representative for a
specific domain using the current $D$-score model. We can use only the items
that load to the domain in question to calculate the $D$-score for that specific
domain. Since items may relate to multiple domain, an item can contribute to the
$D$-score for multiple domains. As the $D$-score methodology is developed to
measure a single construct for development, the domain $D$-scores correlate
highly ($r > 0.95$). However, these scores can potentially inform on the cohort
level (Figure \@ref(fig:domaind)) or the individual level (see Figure
\@ref(fig:domaindex)).


```{r domaind, echo=FALSE, fig.cap='(ref:domaind)', fig.keep='all', message=FALSE, warning=FALSE, cache=TRUE, results='hide'}

library(ddomain)
library(dplyr)
library(tidyr)

data_w <- dmetric::gcdg_lean[["itm"]] %>% spread(key = "item", value = "value") %>%
  left_join(gcdg_lean[["visit"]]) %>%
  mutate(age = agedays/365.25)

d_dom <- ddomain::d_domain(data = data_w, domain = c("Fine.Motor", "Gross.Motor", "Expressive", "Receptive", "Cognitive", "Adaptive"), items = gseddata::gcdg_items,domaintable = ddomain::get_domaintable(key = "gcdg"), vote_weight = 0)
d_all <- dscore(data = data_w, items = gseddata::gcdg_items, itembank = dscore::builtin_itembank, key = "gcdg")
d_dom <- cbind(d_all, d_dom)

cor(d_dom[,c("d" ,"d_Fine.Motor", "d_Gross.Motor", "d_Cognitive", "d_Receptive", "d_Expressive")], use = "complete.obs")

d_dom_d <- d_dom %>% 
  cbind(data_w[,c("cohort", "age"),]) %>%
  pivot_longer(cols = c("d_Fine.Motor", "d_Gross.Motor", "d_Cognitive", "d_Receptive", "d_Expressive"), names_to = "domain1", values_to = "d1") %>% 
  select(c("cohort", "domain1", "d1", "a"))%>% 
  mutate(domain = gsub("d_", "", .data$domain1)) %>%
  rename(d = d1) %>% group_by(cohort, domain) %>%
  summarize( d= mean(d, na.rm = TRUE))

ggplot(d_dom_d, aes( x= cohort, y = d, color = domain))+
  geom_point()+
  coord_flip()+
  ylab("Average domain specific D-score") +
  xlab("")+
  theme( legend.position = "top", legend.title = element_blank())

```
(ref:domaind) Domain $D$-scores per cohort. 

In Figure \@ref(fig:domaindex) example scores are displayed for a 3 year old boy
from the Chili 2 (GCDG-CHL-2) cohort. The grey line displayes the overall
$D$-score (38.55$D$) and the colored points are the domain $D$-scores. This
plots shows that for the language domains (i.e. Expressive and Receptive), this
boy scores relatively low as compared to the motor and cognitive domains. The
bars at the bottom of the plots display the available items per domain. Note
that the number of items for Gross Motor is very low (only 3 items). The white
overlayed line at 5 items, indicates the bare minimum for a $D$-score.


```{r domaindex, echo=FALSE, fig.cap=, fig.keep='all', message=FALSE, warning=FALSE, results='hide'}
#calculate dscore per domain by using only items that are loading on the domain - items can load on multiple domains
#use vote_weight to indicate the minimum percentage of votes for the domain (ex. 0.5 at least half of the votes must be on the domain for that item to load on that domain)

data_w <- dmetric::gcdg_lean[["itm"]] %>% spread(key = "item", value = "value") %>%
  left_join(gcdg_lean[["visit"]]) %>%
  mutate(age = agedays/365.25)
dati <- data_w[9817,]

library(ddomain)
d_dom_ex <- d_domain(data = dati, domain = c("Fine.Motor", "Gross.Motor", "Expressive", "Receptive", "Cognitive", "Adaptive"), items = gseddata::gcdg_items,domaintable = ddomain::get_domaintable(key = "gcdg"), vote_weight = 0)


d_dom_ex_d <- d_dom_ex %>% pivot_longer(cols = c("d_Fine.Motor", "d_Gross.Motor", "d_Cognitive", "d_Receptive", "d_Expressive"), names_to = "domain", values_to = "d") %>% select(c("domain", "d", "a"))%>% mutate(domain = gsub("d_", "", .data$domain))

d_dom_ex_sem <- d_dom_ex %>% pivot_longer(cols = c("sem_Fine.Motor", "sem_Gross.Motor", "sem_Cognitive", "sem_Receptive", "sem_Expressive"), names_to = "domain", values_to = "sem") %>% select(c("domain", "sem"))%>% mutate(domain = gsub("sem_", "", .data$domain))

d_dom_ex_n <- d_dom_ex %>% pivot_longer(cols = c("n_Fine.Motor", "n_Gross.Motor", "n_Cognitive", "n_Receptive", "n_Expressive"), names_to = "domain", values_to = "n") %>% select(c("domain", "n")) %>% mutate(domain = gsub("n_", "", .data$domain))

d_dom_plot <- left_join(d_dom_ex_d, d_dom_ex_n, by = "domain")
d_dom_plot <- left_join(d_dom_plot, d_dom_ex_sem, by = "domain")

d_all <- dscore::dscore(data = dati, items =gseddata::gcdg_items )


ggplot(data = d_dom_plot, aes(x = domain, y = d, color = domain))+
  geom_point() + geom_errorbar(aes(x = domain, ymin = (d-sem), ymax = (d+sem)), width = .1)+
  geom_abline(intercept = d_all$d, slope = 0, col = "darkgrey")+
  geom_abline(intercept = (d_all$d-d_all$sem), slope = 0, lty=2, col = "grey")+
  geom_abline(intercept =(d_all$d+d_all$sem), slope = 0, lty = 2, col = "grey")+
  geom_bar(stat = "identity", aes(x = domain, y = n, fill = domain))+
  geom_abline(intercept = 5, slope = 0, col = "white")+

 ylim(0,80) +
  ylab("number of items                                        D-score") +
  xlab("")+
  theme(legend.position = "none")


```
(ref:domaindex) Domain $D$-scores for a 3 year old boy from the Chile 2 cohort. 
