```{r ch6libs, include=FALSE}
library(ggplot2)
library(dmetric)
library(gseddata)
library(kableExtra)
library(ddomain)
library(dplyr)
library(tidyr)
library(dscore)
```
# Comparing ability {#ch:ability}

In this chapter the $D$-score distributions per GCDG cohort are displayed and
the impact of measurement error is compared between the cohorts. Additionally
the coverage of the developmental domains is displayed for $D$-score scale and
for a single $D$-score.

* $D$-score distribution by study (\@ref(sec:dscores))
* Impact of measurement error (\@ref(sec:sem))
* Domain coverage and scores (\@ref(sec:domains))

## $D$-score distribution by study {#sec:dscores}

For each study that is included in the GCDG assembly, the $D$-score can be
obtained using the developed global model. In Figure \@ref(fig:dscoredist), the $D$-score
distributions are displayed for each cohort separately. The blue lines in the
graphs are the (temporary) references, as explained in \@ref(sec:references).

```{r dscoredist, echo=FALSE, out.width="760px", fig.cap = '(ref:semforn)'}
knitr::include_url("https://iriseekhout.github.io/dbook2tools/gcdgdscores/", 
  height = "800px")
```
(ref:dscoredist) $D$-score distributions by study.


## Impact of measurement error {#sec:sem}

For each estimated $D$-score from the calibrated model, the precision of the
estimate can be determined. This precision can be expressed as the standard
error of measurement ($sem$). The standard error of measurement is inversely
related to the number of items. Thus, when more items are administered for a
person, the measurement error for the $D$-score of this person is smaller.
As is shown in Figure \@ref(fig:semforn), the $sem$ drops fast when the number of
items is increased to 15, and still some more until the number of items is 30.
More than 30 items has little effect on the $sem$.


```{r semforn, results = 'hide', fig.keep = 'all', fig.cap = '(ref:semforn)', echo = FALSE}
ggplot(data = dmetric::model_lean$dscore )+
  geom_smooth(aes(x=n, y=sem), se = FALSE, color = "red")+
  xlab("number of items")
```
(ref:semforn) Standard error of measurement ($sem$) when the number of items increase.


The precision of the $D$-score estimate is also affected by the information that
the items that are administered contribute to the $D$-score. The information
that in item contributes is larger when the item discrimminates well between
different reponders. Therefore, the information is a function of the probability
to endore the item. For example, if the items are too easy and the probability
to pass the item given the $D$-score is $P$ > 0.90, the $sem$ is larger than
when the difficulty of the administered items is closer to the $D$-score (i.e.
$P$ = 0.50). The $sem$ for age in GCDG data (see Figure \@ref(fig:semfora))
shows that for some ages, the $sem$ is larger than for others. This is on the
one hand due to the number of items available in that age range, but also to the
design of the cohorts where sometimes relatively easy items are administered.


```{r semfora, echo=FALSE, fig.cap='(ref:semfora)', fig.keep='all', results='hide'}
# voor individuele metingen
sem_daz <- dmetric::model_lean$dscore %>%
  mutate(agemos = a *12,
         low_d = d - sem,
         high_d = d +sem, 
         low_daz = dscore::daz(low_d, x = a),
         high_daz = dscore::daz(high_d, x = a))


## of dit berekenen via de pooled sem per age group en daarna pas naar daz omzetten
#pooled sem = srqt(sum(sem^2)/(length(sem)-1))
#alleen gaat het dan mis dat de gemiddelde daz soms buiten het inderval komt (in begin maanden vooral)
#>># proberen door between variantie (var(d)) toe te voegen aan de pooling van de varianties
sem_daz_a <- sem_daz %>% 
  mutate(agecat = cut(agemos, breaks = 0:max(agemos, na.rm=TRUE)), 
         agenum = as.numeric(agecat))%>%
  group_by(agenum) %>% 
  summarize (daz = mean(daz, na.rm = TRUE),
             mean_a = mean(a, na.rm=TRUE), #voor omzetting naar daz
             mean_d = mean(d, na.rm = TRUE),
             var_betw = var(d, na.rm = TRUE),
             var_with = sum(sem^2, na.rm = TRUE),
             n =  sum(!is.na(sem))
             ) %>% ungroup() %>%
  mutate(sem_pool = sqrt((var_with + var_betw)/ (n-1)), 
         low_d = mean_d - sem_pool,
         high_d = mean_d + sem_pool,
         mean_daz = dscore::daz(mean_d, x = mean_a),
         low_daz = dscore::daz(low_d, x = mean_a),
         high_daz = dscore::daz(high_d, x = mean_a))

#ggplot(data = sem_daz_a )+
#  geom_point(aes(x=agenum, y=daz)) +
#  geom_errorbar(aes(x = agenum, ymin=low_daz, ymax=high_daz), width=.1)+
#  xlab("age(months)")+
#  ylim(c(-2,2))

ggplot(data = sem_daz_a )+
  geom_point(aes(x=agenum, y=mean_daz)) +
  geom_errorbar(aes(x = agenum, ymin=low_daz, ymax=high_daz), width=.1)+
  xlab("age(months)")+ ylab("DAZ")+
  ylim(c(-2,2))

#ggplot(data = sem_daz_a )+
#  geom_point(aes(x=agenum, y=mean_d)) +
#  geom_errorbar(aes(x = agenum, ymin=low_d, ymax=high_d), width=.1)+
#  xlab("age(months)") + ylab("D-score")


```
(ref:semfora) Standard error of measurement ($sem$) in each age group.

In Figure \@ref(fig:dscoresems), the $sem$ per age group is shown for each
cohort separately. This illustrates the differences in design between the
cohorts. For example, the Netherlands 1 cohort (GCDG-NLD-SMOCC), the `ddi` was
used as a screener and items had the probability to pass of approximately
$P$=0.80 (quartile range between 0.62 < $P$ > 1.00), and the number of items
administered per measurement is about 10 items (quartile range 6 to 12 items).
The Colombia 1 cohort (GCDG-COL-LT45M) was an impact evaluation and has
administered the `by3` where each child answered on average 45 items (quartile
range 38 to 57 items) and the probability to pass was approximately $P$ = 0.64
(quartile range between 0.53 < $P$ > 0.79). The latter study has therefore more
precise $D$-score estimates.

```{r dscoresems, echo=FALSE, out.width="760px", fig.cap = '(ref:dscoresems)'}
#n items per child Netherlands 1 cohort = 8.5
#ids <- gcdg_lean$visit$subjid[which(gcdg_lean$visit$cohort=="GCDG-NLD-SMOCC")]
#itm <- gcdg_lean$itm[which(gcdg_lean$itm$subjid %in% ids),]
#itmn <- itm %>% group_by(subjid, agedays) %>% summarize(n=n())
#summary(itmn)
#p per child on average for Netherlands 1 cohort = 0.8 (median)
#summary(model_lean$dscore$p[which(model_lean$dscore$cohort == "GCDG-NLD-SMOCC")])

#n items per child Colombia cohort = 46
#ids <- gcdg_lean$visit$subjid[which(gcdg_lean$visit$cohort=="GCDG-COL-LT45M")]
#itm <- gcdg_lean$itm[which(gcdg_lean$itm$subjid %in% ids),]
#itmn <- itm %>% group_by(subjid, agedays) %>% summarize(n=n())
#summary(itmn)
#p per child on average for Colombia 1 cohort = 0.63 (median)
#summary(model_lean$dscore$p[which(model_lean$dscore$cohort == "GCDG-COL-LT45M")])
#knitr::include_app("https://tnochildhealthstatistics.shinyapps.io/GCDG_sem/", 
#  height = "700px")
knitr::include_url("https://iriseekhout.github.io/dbook2tools/gcdgsem/",
                   height = "800px")
```
(ref:dscoresems) The standard error of measurement ($sem$) around the age-standardized $D$-scores (DAZ) per cohort

The $sem$ for an entire cohort or sample can be obtained by pooling the
individual $sem_i$ using general rule for pooling variances. Accordingly, the
$sem$ for a sample is obtained by combining the within variance
$\sum{sem_{i}^2}$ and the between variance $\sigma_d$ as in equation
\@ref(eq:poolsem)

\begin{equation}
sem = \sqrt{\frac{\sum{sem_{i}^2} + \sigma_d }{N-1}} (\#eq:poolsem)
\end{equation}

In Figure \@ref(fig:cohortsem) the sample $sem$ per cohort is displayed. The
lowest sample $sem$ is found in the Ethiopia study (GCDG-ETH) and the highest in
the South Africa cohort (GCDG-ZAF). This can be explained on the one hand by the
number of items per child, and on the other hand the difficulty of the
administered items (i.e. the item information). 

```{r cohortsem, results = 'hide', fig.keep = 'all',  fig.cap = '(ref:cohortsem)', echo = FALSE}
sem_daz_c <- sem_daz %>% 
  mutate(agecat = cut(agemos, breaks = 0:max(agemos, na.rm=TRUE)), 
         agenum = as.numeric(agecat))%>%
  group_by(cohort) %>% summarize ("n Q1(0.25)" = quantile(n, probs = 0.25, na.rm=TRUE), 
                                  "test length (median)" = median(n, na.rm = TRUE), 
                                  "n Q3(0.75)" = quantile(n, probs = 0.75, na.rm=TRUE), 
                                  "p Q1(0.25)" = round(quantile(p, probs = 0.25, na.rm=TRUE),2), 
                                  "pass probability (median)" = round(median(p, na.rm=TRUE),2),
                                  "p Q3(0.75)" = round(quantile(p, probs = 0.75, na.rm=TRUE),2),
                                  daz = mean(daz, na.rm = TRUE),
                                  mean_a = mean(a, na.rm=TRUE), #voor omzetting naar daz
                                  mean_d = mean(d, na.rm = TRUE),
                                  var_betw = var(d, na.rm = TRUE),
                                  var_with = sum(sem^2, na.rm = TRUE),
                                  n =  sum(!is.na(sem))
  ) %>% ungroup() %>%
  mutate(sem_pool = sqrt((var_with + var_betw)/ (n-1)), 
         low_d = mean_d - sem_pool,
         high_d = mean_d + sem_pool,
         mean_daz = dscore::daz(mean_d, x = mean_a),
         low_daz = dscore::daz(low_d, x = mean_a),
         high_daz = dscore::daz(high_d, x = mean_a)) %>%
  arrange(sem_pool)

  ggplot(data = sem_daz_c, aes(reorder(cohort, sem_pool), sem_pool)) +
  geom_col() + theme(axis.text.x = element_text(angle = 60, hjust = 1))+
    xlab("")+ ylab("cohort sem")
  
  ## attach main instrument to cohort and see if that relates to sem? Or study kind? Something like that?
 
```
(ref:cohortsem) Standard Error of Measurement ($sem$) per cohort.


Table \@ref(tab:npsem) shows the median
number of items per child (test length) and the probability to pass the items. In the
Ethiopia cohort (`GCDG-ETH`) 39 items were administered with a median
probability of 0.66 and in the South Africa study (`GCDG-ZAF`) just 12 items with a median
probability of 1. Accordingly, in the Ethiopia study more items were
administered per child that also have a high level of information for the
$D$-scores. In the South Africa study only few items were administered per child
that were also relatively easy and therefore contained less information for the
$D$-scores.


```{r npsem, echo = FALSE}
kable(sem_daz_c[,c(1,3,6)], 
      caption = "Test length and probability to pass the items per cohort",
      bootabs = TRUE)

```
&nbsp;

## Domain coverage and scores {#sec:domains}
 
The $D$-score is a one number score that measures early child development. To
evaluate the content validity of the $D$-score we can make sure that all
developmental domains are fairly represented. We distinguish five domains for
child development: Fine Motor, Gross Motor, Expressive, Receptive, Cognitive. 

### Domain coverage of the scale

The items in the $D$-score model can be linked to one or more domains and the
cumulative item information to the $D$-score for each domain can be evaluated.
In Figure \@ref(fig:domaincov), the coverage of the domains for the $D$-score is
displayed. This shows that at lower levels of the $D$-score, gross motor development
is more dominant and that at higher levels of the $D$-score the cognitive and
language domains increase in importance.


```{r domaincov, results = 'hide', fig.keep = 'all', fig.cap = '(ref:domaincov)', echo = FALSE, fig.width=11}
info_data <-
      dinstrument::info_d_item(
        itembank = model_lean$itembank,
        delta = "tau",
        alpha = NULL,
        long = TRUE,
        beta_range = 0:80
      )

 #deal with missings in votes by then setting to instrument domain for 100%
 domaintable <- ddomain::get_domaintable("gcdg") %>%
         mutate(Fine.Motor = ifelse(is.na(Fine.Motor) & domain == "Fine Motor", 1, Fine.Motor),
          Fine.Motor = ifelse(is.na(Fine.Motor) & domain != "Fine Motor", 0, Fine.Motor),
          Gross.Motor = ifelse(is.na(Gross.Motor) & domain == "Gross Motor", 1, Gross.Motor),
          Gross.Motor = ifelse(is.na(Gross.Motor) & domain != "Gross Motor", 0, Gross.Motor), 
          Expressive = ifelse(is.na(Expressive) & domain == "Expressive", 1, Expressive),
          Expressive = ifelse(is.na(Expressive) & domain != "Expressive", 0, Expressive), 
          Receptive = ifelse(is.na(Receptive) & domain == "Receptive", 1, Receptive),
          Receptive = ifelse(is.na(Receptive) & domain != "Receptive", 0, Receptive), 
          Cognitive = ifelse(is.na(Cognitive) & domain == "Cognitive", 1, Cognitive),
          Cognitive = ifelse(is.na(Cognitive) & domain != "Cognitive", 0, Cognitive), 
          Adaptive = ifelse(is.na(Adaptive) & domain == "Adaptive", 1, Adaptive),
          Adaptive = ifelse(is.na(Adaptive) & domain != "Adaptive", 0, Adaptive))

 info_wby_domain <- info_data %>% left_join(domaintable) %>%
        mutate(
          gm_info = .data$Gross.Motor * .data$info,
          fm_info = .data$Fine.Motor * .data$info,
          exp_info = .data$Expressive * .data$info,
          rec_info = .data$Receptive * .data$info,
          cog_info = .data$Cognitive * .data$info,
          adp_info = .data$Adaptive * .data$info) %>%
        group_by(ability) %>%
        summarise(
          "Gross Motor" = sum(.data$gm_info, na.rm = TRUE)/sum(.data$info, na.rm = TRUE) *100,
          "Fine Motor" = sum(.data$fm_info, na.rm = TRUE)/sum(.data$info, na.rm = TRUE) *100,
          "Expressive" = sum(.data$exp_info, na.rm = TRUE)/sum(.data$info, na.rm = TRUE) *100,
          "Receptive" = sum(.data$rec_info, na.rm = TRUE)/sum(.data$info, na.rm = TRUE) *100,
          "Cognitive" = sum(.data$cog_info, na.rm = TRUE)/sum(.data$info, na.rm = TRUE) *100,
          "Adaptive" = sum(.data$adp_info, na.rm=TRUE)/sum(.data$info, na.rm = TRUE) *100,
          missing = (sum(.data$info) - sum(.data$gm_info, na.rm = TRUE) -
                       sum(.data$fm_info, na.rm = TRUE) - sum(.data$cog_info, na.rm = TRUE) -
                       sum(.data$exp_info, na.rm = TRUE) - sum(.data$rec_info, na.rm = TRUE) - sum(.data$adp_info, na.rm=TRUE) ) /sum(.data$info, na.rm = TRUE) *100
        ) %>%
        gather(key = "domain",
               value = "info",
               "Gross Motor",
               "Fine Motor",
               "Receptive",
               "Expressive",
               "Cognitive",
               "Adaptive",
               missing) %>%
        mutate(domain = ifelse(.data$domain =="missing",  NA, .data$domain))

 
    ggplot(data = info_wby_domain, aes(x = ability, y = info, fill = domain)) +
      geom_bar(stat = "identity", width = 1) +
      ylab("% of information") +
      xlab("Ability (D-score)")+
      scale_color_manual(values = dmodel::get_color_domain("gcdg"),
                         na.value = "grey")

  

```
(ref:domaincov) Domain coverage of the $D$-score scale.

Note that for some items the domain allocation is missing.  

### Domain $D$-scores

It is possible to calculate a $D$-score that is more representative for a
specific domain using the current $D$-score model. We can use only the items
that load to the domain in question to calculate the $D$-score for that specific
domain. Since items may relate to multiple domains, an item can contribute to
multiple domain specific $D$-scores. As the $D$-score methodology is developed
to measure a single construct for development, the domain $D$-scores correlate
highly ($r > 0.95$). However, these scores can potentially inform on the cohort
level (Figure \@ref(fig:domaind)) or the individual level (see Figure
\@ref(fig:domaindex)).

In Figure \@ref(fig:domaind), the domain scores are presented for the cohorts in DAZ units to enable comparison between and within studies. The $sem$ intervals are displayed in the error bars around the scores. The mean domain DAZ scores differ within some cohorts, however, the $sem$ ranges always overlap. 
<!--- the correlations between the daz scores are much lower. How should we interpet that? I think it may also be due to differences in precision of the maesurement. The correlations to the daz based on all items may also be informative on that. Gross motor has low correlations to all scales, but that may also be due to nr of items. --->

```{r domaind, echo=FALSE, fig.cap='(ref:domaind)', fig.keep='all', cache=TRUE, results='hide', fig.width=11}
data_w <- dmetric::gcdg_lean[["itm"]] %>% spread(key = "item", value = "value") %>%
  left_join(gcdg_lean[["visit"]]) %>%
  mutate(age = agedays/365.25)

d_dom <- ddomain::d_domain(data = data_w, domain = c("Fine.Motor", "Gross.Motor", "Expressive", "Receptive", "Cognitive", "Adaptive"), items = gseddata::gcdg_items,domaintable = ddomain::get_domaintable(key = "gcdg"), vote_weight = 0)
d_all <- dscore(data = data_w, items = gseddata::gcdg_items, itembank = dscore::builtin_itembank, key = "gcdg")
d_dom1 <- cbind(d_all, d_dom)

cor(d_dom1[,c("daz" ,"daz_Fine.Motor", "daz_Gross.Motor", "daz_Cognitive", "daz_Receptive", "daz_Expressive")], use = "complete.obs")

d_dom_d <- d_dom %>% 
  cbind(data_w[,c("cohort", "subjid", "agedays"),]) %>%
  pivot_longer(cols = c("d_Fine.Motor", "d_Gross.Motor", "d_Cognitive", "d_Receptive", "d_Expressive",
                        "sem_Fine.Motor", "sem_Gross.Motor", "sem_Cognitive", "sem_Receptive", "sem_Expressive"), values_to = "score", names_to = c("stat", "domain"), names_sep = "_" ) %>% 
  select(c("subjid", "cohort","agedays", "domain", "stat", "score")) %>%
  pivot_wider(id_cols = c("subjid", "agedays","cohort", "domain"), names_from = "stat", values_from = "score", values_fn = list(score = first))%>%
  group_by(cohort, domain)%>%
  summarize (mean_a = mean((agedays/365.25), na.rm=TRUE), #voor omzetting naar daz
             mean_d = mean(d, na.rm = TRUE),
             var_betw = var(d, na.rm = TRUE),
             var_with = sum(sem^2, na.rm = TRUE),
             n =  sum(!is.na(sem))
             ) %>% ungroup() %>%
  mutate(sem_pool = sqrt((var_with + var_betw)/ (n-1)), 
         low_d = mean_d - sem_pool,
         high_d = mean_d + sem_pool,
         mean_daz = dscore::daz(mean_d, x = mean_a),
         low_daz = dscore::daz(low_d, x = mean_a),
         high_daz = dscore::daz(high_d, x = mean_a))



ggplot(d_dom_d, aes( x= reorder(cohort, desc(cohort)), y = mean_daz, color = domain))+
  geom_point(size = 1, position = position_dodge(width = 0.5))+
  geom_errorbar(aes(x = cohort, ymin = (low_daz), ymax = (high_daz), group = domain), width = .1,position = position_dodge(width = 0.5))+
 # coord_flip()+
  ylab("Average domain specific DAZ") +
  ylim(-4,4)+
  xlab("")+
  theme( legend.position = "top", legend.title = element_blank(),
         axis.text.x = element_text(angle = 90))

##consider adding the sem intervals >> cohort sems!

```
(ref:domaind) Domain $D$-scores per cohort. 

In Figure \@ref(fig:domaindex) example scores are displayed for a 3 year old boy
from the Chili 2 (`GCDG-CHL-2`) cohort. The filled bars display the available items per domain. Note
that the number of items for Gross Motor is very low (only 3 items). The white
overlayed line at 5 items, indicates the bare minimum for a $D$-score. The grey vertical line displays the overall
$D$-score (38.55$D$) with the $sem$ (0.53) around as the dashed lines. The colored points are the domain $D$-scores with the $sem$ around in error bars. This plot shows that for the language domains (i.e. Expressive and Receptive), this boy scores relatively low as compared to the motor and cognitive domains. 


```{r domaindex, echo=FALSE, fig.cap='(ref:domaindex)', fig.keep='all', results='hide', fig.width=11,fig.height=4}
#calculate dscore per domain by using only items that are loading on the domain - items can load on multiple domains
#use vote_weight to indicate the minimum percentage of votes for the domain (ex. 0.5 at least half of the votes must be on the domain for that item to load on that domain)

data_w <- dmetric::gcdg_lean[["itm"]] %>% spread(key = "item", value = "value") %>%
  left_join(gcdg_lean[["visit"]]) %>%
  mutate(age = agedays/365.25)
dati <- data_w[9817,]

d_dom_ex <- d_domain(data = dati, domain = c("Fine.Motor", "Gross.Motor", "Expressive", "Receptive", "Cognitive", "Adaptive"), items = gseddata::gcdg_items,domaintable = ddomain::get_domaintable(key = "gcdg"), vote_weight = 0)


d_dom_ex_d <- d_dom_ex %>% select(c("a", "d_Fine.Motor", "d_Gross.Motor", "d_Cognitive", "d_Receptive", "d_Expressive")) %>% pivot_longer(cols = c("d_Fine.Motor", "d_Gross.Motor", "d_Cognitive", "d_Receptive", "d_Expressive"), names_to = "domain", values_to = "d") %>% mutate(domain = gsub("d_", "", .data$domain))

d_dom_ex_sem <- d_dom_ex %>% select(c("sem_Fine.Motor", "sem_Gross.Motor", "sem_Cognitive", "sem_Receptive", "sem_Expressive")) %>% pivot_longer(cols = c("sem_Fine.Motor", "sem_Gross.Motor", "sem_Cognitive", "sem_Receptive", "sem_Expressive"), names_to = "domain", values_to = "sem") %>% mutate(domain = gsub("sem_", "", .data$domain))

d_dom_ex_n <- d_dom_ex %>% select(c("n_Fine.Motor", "n_Gross.Motor", "n_Cognitive", "n_Receptive", "n_Expressive")) %>% pivot_longer(cols = c("n_Fine.Motor", "n_Gross.Motor", "n_Cognitive", "n_Receptive", "n_Expressive"), names_to = "domain", values_to = "n") %>% mutate(domain = gsub("n_", "", .data$domain))

d_dom_plot <- left_join(d_dom_ex_d, d_dom_ex_n, by = "domain")
d_dom_plot <- left_join(d_dom_plot, d_dom_ex_sem, by = "domain")

d_all <- dscore(data = dati, items = gseddata::gcdg_items, itembank = dscore::builtin_itembank, key = "gcdg")



ggplot(data = d_dom_plot, aes(x = domain, y = d, color = domain))+
  geom_point() + geom_errorbar(aes(x = domain, ymin = (d-sem), ymax = (d+sem)), width = .1)+
  geom_abline(intercept = d_all$d, slope = 0, col = "darkgrey")+
  geom_abline(intercept = (d_all$d-d_all$sem), slope = 0, lty=2, col = "grey")+
  geom_abline(intercept =(d_all$d+d_all$sem), slope = 0, lty = 2, col = "grey")+
  geom_bar(stat = "identity", aes(x = domain, y = n, fill = domain))+
  geom_abline(intercept = 5, slope = 0, col = "white")+

 ylim(0,80) +
  ylab("number of items                                                                                                    D-score") +
  xlab("")+
  theme(legend.position = "none")+
  coord_flip()


```
(ref:domaindex) Domain $D$-scores for a 3 year old boy from the Chile 2 cohort. 
