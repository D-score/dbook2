---
runtime: shiny 
---

# Comparing ability {#ch:ability}

In this chapter the $D$-score distributions per GCDG cohort are displayed and
the impact of measurement error is compared between the cohorts. Additionally
the coverage of the developmental domains is displayed for different levels of
the $D$-score.

* D-score distribution by study (\@ref(sec:dsores))
* Impact of measurement error (\@ref(sec:sem))
* Domain coverage (\@ref(sec:domains))


## D-score distribution by study {#sec:dsores}

For each study that is included in the GCDG assembly, the $D$-score can be
obtained using the developed global model. In the graphs below, the $D$-score
distributions are displayed for each cohort seperately. The blue lines in the
graphs are the (temporary) references, as explained in (@\ref(sec:references)).
By using the "next" button below the plot you can click through the cohorts.
Using the selection bar above the graph, you can select a specific cohort.

```{r}
knitr::include_app("https://tnochildhealthstatistics.shinyapps.io/GCDG_dsores/", 
  height = "600px")
```
(ref:dscoredist) $D$-score distributions by study.


## Impact of measurement error {#sec:sem}

For each estimated $D$-score from the calibrated model, the precision of the
estimate can be determined. This precision can be expressed as the standard
error of measurement ($sem$). The standard error of measurement is inversely
related to the number of items. Thus, when more items are administered for a
person, the measurement error for the $D$-score of this person will be smaller.
As is shown in figure \@ref(fig:semforn), the sem drops fast when the number of
items is increased to 15, and still some more until the number of items is 30.
More than 30 items has little effect on the sem.


```{r semforn, results = 'hide', fig.keep = 'all', fig.height = 11, warning = FALSE, fig.cap = '(ref:semforn)', message = FALSE}

ggplot(data = dmetric::model_lean$dscore )+
  geom_smooth(aes(x=n, y=sem), se = FALSE, color = "red")+
  xlab("number of items")
```
(ref:semforn) Standard error of measurement when the number of items increases.


The precision of the $D$-score estimate is also affected by the information in
the items that are administered. This is partly the number of items, as depicted
in \@ref(fig:semforn), but also if the items are informative for the $D$-score.
For example, if the items are too easy and the probability to pass the item
given the $D$-score is $P$ > 0.90, the $sem$ is larger than when the difficulty
of the administered items is closer to the $D$-score (i.e. $P$ = 0.50). The sem
for age in GCDG data shows that for some ages, the sem is larger than for others
(see Figure \@ref(fig:semfora)). This is on the one hand due to the number of
items available in that age range, but also to the design of the cohorts where
sometimes relatively easy items are administered.


```{r semfora, results = 'hide', fig.keep = 'all', fig.height = 11, warning = FALSE, fig.cap = '(ref:semfora)', message = FALSE}
library("dmetric")
library("gseddata")
library("dplyr")

# voor individuele metingen
sem_daz <- dmetric::model_lean$dscore %>%
  mutate(agemos = a *12,
         low_d = d - sem,
         high_d = d +sem, 
         low_daz = dscore::daz(low_d, x = a),
         high_daz = dscore::daz(high_d, x = a))


## of dit berekenen via de pooled sem per age group en daarna pas naar daz omzetten
#pooled sem = srqt(sum(sem^2)/(length(sem)-1))
#alleen gaat het dan mis dat de gemiddelde daz soms buiten het inderval komt (in begin maanden vooral)
#>># proberen door between variantie (var(d)) toe te voegen aan de pooling van de varianties
sem_daz_a <- sem_daz %>% 
  mutate(agecat = cut(agemos, breaks = 0:max(agemos, na.rm=TRUE)), 
         agenum = as.numeric(agecat))%>%
  group_by(agenum) %>% 
  summarize (daz = mean(daz, na.rm = TRUE),
             mean_a = mean(a, na.rm=TRUE), #voor omzetting naar daz
             mean_d = mean(d, na.rm = TRUE),
             var_betw = var(d, na.rm = TRUE),
             var_with = sum(sem^2, na.rm = TRUE),
             n =  sum(!is.na(sem))
             ) %>% ungroup() %>%
  mutate(sem_pool = sqrt((var_with + var_betw)/ (n-1)), 
         low_d = mean_d - sem_pool,
         high_d = mean_d + sem_pool,
         mean_daz = dscore::daz(mean_d, x = mean_a),
         low_daz = dscore::daz(low_d, x = mean_a),
         high_daz = dscore::daz(high_d, x = mean_a))

#ggplot(data = sem_daz_a )+
#  geom_point(aes(x=agenum, y=daz)) +
#  geom_errorbar(aes(x = agenum, ymin=low_daz, ymax=high_daz), width=.1)+
#  xlab("age(months)")+
#  ylim(c(-2,2))

ggplot(data = sem_daz_a )+
  geom_point(aes(x=agenum, y=mean_daz)) +
  geom_errorbar(aes(x = agenum, ymin=low_daz, ymax=high_daz), width=.1)+
  xlab("age(months)")+ ylab("daz")+
  ylim(c(-2,2))

#ggplot(data = sem_daz_a )+
#  geom_point(aes(x=agenum, y=mean_d)) +
#  geom_errorbar(aes(x = agenum, ymin=low_d, ymax=high_d), width=.1)+
#  xlab("age(months)") + ylab("D-score")


```
(ref:semfora) Standard error of measurement in each age group.

In Figure (\@ref(ref:dscoresems)), the $sem$ per age group is shown for each
cohort seperately. This illustrates the differences in design between the
cohorts. For example, the Netherlands 1 cohort (GCDG-NLD-SMOCC), the ddi was
used as a screener and items had the probability to pass of approximately
$P$=0.80 (quartile range between 0.62 < $P$ > 1.00), and the number of items
administered per measurement is about 10 items (quartile range 6 to 12 items).
The Colombia 1 cohort (GCDG-COL-LT45M) was an impact evaluation and has
administered the by3 where each child answered on average 45 items (quartile
range 38 to 57 items) and the probablity to pass was approximately $P$ = 0.64
(quartile range betweeen 0.53 < $P$ > 0.79). The latter study has therefore more
precise $D$-score estimates.

```{r}
#n items per child Netherlands 1 cohort = 8.5
#ids <- gcdg_lean$visit$subjid[which(gcdg_lean$visit$cohort=="GCDG-NLD-SMOCC")]
#itm <- gcdg_lean$itm[which(gcdg_lean$itm$subjid %in% ids),]
#itmn <- itm %>% group_by(subjid, agedays) %>% summarize(n=n())
#summary(itmn)
#p per child on average for Netherlands 1 cohort = 0.8 (median)
#summary(model_lean$dscore$p[which(model_lean$dscore$cohort == "GCDG-NLD-SMOCC")])

#n items per child Colombia cohort = 46
#ids <- gcdg_lean$visit$subjid[which(gcdg_lean$visit$cohort=="GCDG-COL-LT45M")]
#itm <- gcdg_lean$itm[which(gcdg_lean$itm$subjid %in% ids),]
#itmn <- itm %>% group_by(subjid, agedays) %>% summarize(n=n())
#summary(itmn)
#p per child on average for Colombia 1 cohort = 0.63 (median)
#summary(model_lean$dscore$p[which(model_lean$dscore$cohort == "GCDG-COL-LT45M")])


knitr::include_app("https://tnochildhealthstatistics.shinyapps.io/GCDG_sem/", 
  height = "800px")
```
(ref:dscoresems) Standard Error of Measurment for age by cohort

The $sem$ for an entire cohort or sample can be obtained by pooling the
individual $sem_i$ using general rule for pooling variances. Accordingly, the
$sem$ for a sample is obtained by combining the within variance
$\sum{sem_{i}^2}$ and the between variance $\sigma_d$ as in equation
\@ref(eq:poolsem)

\begin{equation}
sem = \sqrt{\frac{\sum{sem_{i}^2} + \sigma_d }{N-1}} (\#eq:poolsem)
\end{equation}

In Figure \@ref(fig:cohortsem) the sample $sem$ per cohort are displayed. The
lowest sample $sem$ is found in the Ethiopia study (GCDG-ETH) and the highest in
the South Africa cohort (GCDG-ZAF). This can be explained on the one hand by the
number of items per child, and on the other hand the difficulty of the
administered items. Table \@ref(tab:npsem) shows the quartile ranges for the
number of items per child (n) and the probability to pass the items (p). In The
Ethiopia cohort 39 items (Q2; median) were administered with a median
probability of 0.66 and in the South Africa study just 12 items with a median
probability of 1. Accordingly, in the Ethiopia study more items were
administered per child that also have a high level of information for the
$D$-score. In the South Africa study only few items were administered per child
that were also relatively easy and therefore contained less information for the
$D$-score.

```{r cohortsem, results = 'hide', fig.keep = 'all', fig.height = 11, warning = FALSE, fig.cap = '(ref:cohortsem)', message = FALSE}
sem_daz_c <- sem_daz %>% 
  mutate(agecat = cut(agemos, breaks = 0:max(agemos, na.rm=TRUE)), 
         agenum = as.numeric(agecat))%>%
  group_by(cohort) %>% summarize ("n Q1(0.25)" = quantile(n, probs = 0.25, na.rm=TRUE), 
                                  "n Q2(0.50)" = median(n, na.rm = TRUE), 
                                  "n Q3(0.75)" = quantile(n, probs = 0.75, na.rm=TRUE), 
                                  "p Q1(0.25)" = round(quantile(p, probs = 0.25, na.rm=TRUE),2), 
                                  "p Q2(0.50)" = round(median(p, na.rm=TRUE),2),
                                  "p Q3(0.75)" = round(quantile(p, probs = 0.75, na.rm=TRUE),2),
                                  daz = mean(daz, na.rm = TRUE),
                                  mean_a = mean(a, na.rm=TRUE), #voor omzetting naar daz
                                  mean_d = mean(d, na.rm = TRUE),
                                  var_betw = var(d, na.rm = TRUE),
                                  var_with = sum(sem^2, na.rm = TRUE),
                                  n =  sum(!is.na(sem))
  ) %>% ungroup() %>%
  mutate(sem_pool = sqrt((var_with + var_betw)/ (n-1)), 
         low_d = mean_d - sem_pool,
         high_d = mean_d + sem_pool,
         mean_daz = dscore::daz(mean_d, x = mean_a),
         low_daz = dscore::daz(low_d, x = mean_a),
         high_daz = dscore::daz(high_d, x = mean_a)) %>%
  arrange(sem_pool)

  ggplot(data = sem_daz_c, aes(reorder(cohort, sem_pool), sem_pool)) +
  geom_col() + theme(axis.text.x = element_text(angle = 60, hjust = 1))+
    xlab("")+ ylab("cohort sem")
  
  ## attach main instrument to cohort and see if that relates to sem? Or study kind? Something like that?
 
```
(ref:cohortsem) Standard Error of Measurement per cohort.



```{r npsem}

kable(sem_daz_c[,1:7], 
      caption = "Quartiles for the number of items (n) and probability to pass the items (p) per cohort",
      bootabs = TRUE)

```

## Domain coverage {#sec:domains}
 
The $D$-score is a one number score that measures early child development. To
evaluate the content validity of the $D$-score we can make sure that all
developmental domains are fairly respresented. We distinguish five domains for
child development: Motor development (motor), Cognitive development (cog),
Language development (lang), Social-emotional (sem), and Life skills (life). The
items can be linked to one or more domains and the cumulative item information
for each domain can be evaluated. In Figure \@ref(fit:domaincov), the coverage
of the domains for the $D$-score is displayed. This shows that at lower levels
of the $D$-score, motor development is more dominant and that at higher levels
of the $D$-score the cognitive van language domains increase in importance.


```{r}
info_data <-
      dinstrument::info_d_item(
        itembank = model_lean$itembank,
        delta = "tau",
        alpha = NULL,
        long = TRUE,
        beta_range = 0:80
      )
 domaintable <- dmodel::get_domaintable("gcdg")
 info_wby_domain <- info_data %>% left_join(domaintable) %>%
        mutate(
          gm_info = .data$Gross.Motor * .data$info,
          fm_info = .data$Fine.Motor * .data$info,
          exp_info = .data$Expressive * .data$info,
          rec_info = .data$Receptive * .data$info,
          cog_info = .data$Cognitive * .data$info,
          adp_info = .data$Adaptive * .data$info) %>%
        group_by(ability) %>%
        summarise(
          "Gross Motor" = sum(.data$gm_info, na.rm = TRUE),
          "Fine Motor" = sum(.data$fm_info, na.rm = TRUE),
          "Expressive" = sum(.data$exp_info, na.rm = TRUE),
          "Receptive" = sum(.data$rec_info, na.rm = TRUE),
          "Cognitive" = sum(.data$cog_info, na.rm = TRUE),
          "Adaptive" = sum(.data$adp_info, na.rm=TRUE),
          missing = (sum(.data$info) - sum(.data$gm_info, na.rm = TRUE) -
                       sum(.data$fm_info, na.rm = TRUE) - sum(.data$cog_info, na.rm = TRUE) -
                       sum(.data$exp_info, na.rm = TRUE) - sum(.data$rec_info, na.rm = TRUE) - sum(.data$adp_info, na.rm=TRUE) )
        ) %>%
        gather(key = "domain",
               value = "info",
               "Gross Motor",
               "Fine Motor",
               "Receptive",
               "Expressive",
               "Cognitive",
               "Adaptive",
               missing) %>%
        mutate(domain = ifelse(.data$domain =="missing",  NA, .data$domain))

 
    ggplot(data = info_wby_domain, aes(x = ability, y = info, fill = domain)) +
      geom_bar(stat = "identity") +
      ylab("Information") +
      xlab("Ability (D-score)")+
      scale_color_manual(values = dmodel::get_color_domain("gcdg"),
                         na.value = "grey")

  

```

It is possible to calculate a $D$-score that is more representative for a
specific domain using the current $D$-score model. We can use only the items
that load to the domain in question to calculate the $D$-score.


```{r}
#calculate dscore per domain by using only items that are loading on the domain - items can load on multiple domains
#use vote_weight to indicate the minimum percentage of votes for the domain (ex. 0.5 at least half of the votes must be on the domain for that item to load on that domain)
d_domain <- function(data,
                     domaintable = dmodel::get_domaintable("gcdg"),
                     domain, 
                     items = NULL, 
                     vote_weight = NULL){
  lean <- gseddata::is.lean(data)
   
   if(lean){
    data <- data[["itm"]] %>% tidyr::spread(key = "item", value = "value")
   }

   data$age <- data$agedays / 365.25
   
   if(is.null(vote_weight)) {vote_weight <- 0}
   
   if(length(domain) == 1){
   domain_items <- domaintable[domaintable[,domain] > vote_weight, "item"]
   domain_items <- intersect(domain_items, names(data))
   d_domain <- dscore::dscore(data = data, items = domain_items)
   colnames(d_domain)[c(2:6)] <- paste(colnames(d_domain)[c(2:6)], domain, sep = "_")
   }
   
  if(length(domain) > 1){
    d_domain <- dscore::dscore(data = data, items = items)
    
    for(dom in domain){
   dom_items <- domaintable[domaintable[,dom] > vote_weight, "item"]
   dom_items <- intersect(dom_items, names(data))
   d_dom <- dscore::dscore(data = data, items = dom_items)
   colnames(d_dom)[c(2:6)] <- paste(colnames(d_dom)[c(2:6)], dom, sep = "_")
   d_domain <- cbind(d_domain, d_dom[,-1])
    }
  }
   
   d_domain
  
}

#test compare with manual for col1
#start <- Sys.time()
gcdg_all <- d_domain(data = dmetric::gcdg_lean, domain = c("Fine.Motor", "Gross.Motor", "Expressive", "Receptive", "Cognitive", "Adaptive"), items = gseddata::gcdg_items, vote_weight = 0.5)
#Sys.time() - start #2.8min

gcdg_domains <- gcdg_all %>%
  mutate(month = a * 12) %>% 
  select(month, d, "d_Fine.Motor", "d_Gross.Motor", "d_Expressive", "d_Receptive", "d_Cognitive", "d_Adaptive") %>%
  rename("Fine Motor" = d_Fine.Motor, 
         "Gross Motor"= d_Gross.Motor,
         "Expressive" = d_Expressive,
         "Receptive" = d_Receptive,
         "Cognitive" = d_Cognitive,
         "Adaptive" = d_Adaptive) %>%
  pivot_longer(cols = c("Fine Motor", "Gross Motor", "Expressive", "Receptive", "Cognitive", "Adaptive"), names_to = "domain", values_to = "dscore")


#plot all domain dscore in gcdg data
ggplot(data = gcdg_domains)+
  geom_point(aes(x = month, y = dscore, group = domain, col = domain))+
  xlab("Age(month)") + ylab("D-score")+
  scale_color_manual(values = dmodel::get_color_domain("gcdg"), 
                     na.value = "grey")

#example for one person
# i <- 25
# example1d <- gcdg_all[i,] %>%
#   pivot_longer(cols= c(d, d_motor, d_cog, d_lang, d_sem, d_life), names_to = "domain", values_to = "dscore")%>%
#   select(a, domain, dscore)
# 
# example1sem <- gcdg_all[i,] %>%
#   pivot_longer(cols = c(sem, sem_motor, sem_cog, sem_lang, sem_sem, sem_life), names_to = "domain2", values_to = "dsem") %>% select(domain2, dsem) %>% cbind(example1d) %>%
#   select(a, domain, dscore, dsem) %>%
#   mutate(low_d = dscore - dsem, high_d = dscore +dsem, month = a * 12)
# 
#   
#   
#   
#   ggplot(data = example1sem )+
#   geom_point(aes(x=domain, y=dscore)) +
#   geom_errorbar(aes(x = domain, ymin=low_d, ymax=high_d), width=.1)+
#   xlab("domain")+ ylab("D-score")


```

